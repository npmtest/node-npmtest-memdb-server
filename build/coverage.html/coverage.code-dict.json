{"/home/travis/build/npmtest/node-npmtest-memdb-server/test.js":"/* istanbul instrument in package npmtest_memdb_server */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-memdb-server/lib.npmtest_memdb_server.js":"/* istanbul instrument in package npmtest_memdb_server */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_memdb_server = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_memdb_server = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-memdb-server/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-memdb-server && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_memdb_server */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_memdb_server\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_memdb_server.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_memdb_server.rollup.js'] =\n            local.assetsDict['/assets.npmtest_memdb_server.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_memdb_server.__dirname + '/lib.npmtest_memdb_server.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/index.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\nmodule.exports = require('./lib');\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/lib/index.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar P = require('bluebird');\nvar Connection = require('./connection');\nvar AutoConnection = require('./autoconnection');\n\nexports.connect = function(opts){\n    var conn = new Connection(opts);\n    return P.try(function(){\n        return conn.connect();\n    })\n    .thenReturn(conn);\n};\n\nexports.autoConnect = function(opts){\n    var conn = new AutoConnection(opts);\n    return P.resolve(conn);\n};\n\nexports.connectBackend = function(backend){\n    var mongodb = P.promisifyAll(require('mongodb'));\n    return P.promisify(mongodb.MongoClient.connect)(backend.url, backend.options)\n    .then(function(db){\n        var getCollection = db.collection;\n        db.collection = function(){\n            var coll = getCollection.apply(db, arguments);\n            var disabledMethods = ['createIndex', 'drop', 'dropIndex', 'dropIndexes', 'ensureIndex',\n            'findAndModify', 'getCollection', 'getDB', 'insert', 'remove', 'renameCollection', 'save', 'update'];\n            disabledMethods.forEach(function(method){\n                coll[method] = function(){\n                    throw new Error('write to backend is forbidden');\n                };\n            });\n            return coll;\n        };\n        return db;\n    });\n};\n\nObject.defineProperty(exports, 'goose', {\n    get : function(){\n        return require('./mdbgoose');\n    },\n});\n\nObject.defineProperty(exports, 'logger', {\n    get : function(){\n        return require('memdb-logger');\n    },\n});\n\nObject.defineProperty(exports, 'Promise', {\n    get : function(){\n        return require('bluebird');\n    },\n});\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/lib/connection.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar P = require('bluebird');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar clientPool = require('./clientpool');\nvar consts = require('./consts');\nvar logger = require('memdb-logger').getLogger('memdb-client', __filename);\n\nvar Connection = function(opts){\n    EventEmitter.call(this);\n\n    opts = opts || {};\n    this.config = opts;\n    this._client = null;\n    this._connId = null;\n\n    this._collections = {};\n};\n\nutil.inherits(Connection, EventEmitter);\n\nvar proto = Connection.prototype;\n\nproto.connect = function(){\n    if(this._connId){\n        throw new Error('already connected');\n    }\n    var key = this.config.host + ':' + this.config.port;\n\n    return P.bind(this)\n    .then(function(){\n        return clientPool.getClient(this.config.host, this.config.port);\n    })\n    .then(function(client){\n        this._client = client;\n        this._client.on('close', this._close.bind(this));\n\n        return this._client.request(null, 'connect', [consts.version]);\n    })\n    .then(function(ret){\n        this._connId = ret.connId;\n\n        logger.info('[conn:%s] connected on %s:%s', this._connId, this.config.host, this.config.port);\n        return this._connId;\n    });\n};\n\nproto.close = function(){\n    if(!this._connId){\n        throw new Error('not connected');\n    }\n    return P.bind(this)\n    .then(function(){\n        return this._client.request(this._connId, 'disconnect', []);\n    })\n    .then(function(){\n        this._close();\n    });\n};\n\nproto._close = function(){\n    logger.info('[conn:%s] closed on %s:%s', this._connId, this.config.host, this.config.port);\n\n    this._client = null;\n    this._connId = null;\n    this.emit('close');\n};\n\nproto.collection = function(name){\n    var self = this;\n    if(!this._collections[name]){\n        var collection = {};\n\n        consts.collMethods.forEach(function(method){\n            collection[method] = function(){\n                var args = [name].concat([].slice.call(arguments));\n                return self[method].apply(self, args);\n            };\n        });\n\n        this._collections[name] = collection;\n    }\n    return this._collections[name];\n};\n\nconsts.connMethods.concat(consts.collMethods).forEach(function(method){\n    proto[method] = function(){\n        if(!this._connId){\n            throw new Error('not connected');\n        }\n        var args = [].slice.call(arguments);\n        return this._client.request(this._connId, method, args);\n    };\n});\n\nmodule.exports = Connection;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/lib/clientpool.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar P = require('bluebird');\nvar AsyncLock = require('async-lock');\nvar Client = require('./client');\nvar logger = require('memdb-logger').getLogger('memdb-client', __filename);\n\nvar clients = {}; // {'host:port' : client}\nvar connectLock = new AsyncLock();\n\nexports.getClient = function(host, port){\n    var key = host + ':' + port;\n\n    return connectLock.acquire(key, function(){\n        if(clients[key]){\n            return clients[key];\n        }\n\n        var client = new Client();\n        client.setMaxListeners(1025);\n\n        return P.try(function(){\n            return client.connect(host, port);\n        })\n        .then(function(){\n            clients[key] = client;\n\n            client.on('close', function(){\n                delete clients[key];\n            });\n            return client;\n        });\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/lib/client.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar P = require('bluebird');\nvar util = require('util');\nvar net = require('net');\nvar EventEmitter = require('events').EventEmitter;\nvar Protocol = require('./protocol');\nvar logger = require('memdb-logger').getLogger('memdb-client', __filename);\n\nvar Client = function(){\n    EventEmitter.call(this);\n\n    this.protocol = null;\n    this.seq = 1;\n    this.requests = {}; //{seq : deferred}\n    this.domains = {}; //{seq : domain} saved domains\n\n    this.disconnectDeferred = null;\n};\n\nutil.inherits(Client, EventEmitter);\n\nvar proto = Client.prototype;\n\nproto.connect = function(host, port){\n    if(!!this.protocol){\n        throw new Error('connect already called');\n    }\n\n    var self = this;\n    logger.debug('start connect to %s:%s', host, port);\n\n    var connectDeferred = P.defer();\n\n    var socket = net.createConnection(port, host);\n\n    this.protocol = new Protocol({socket : socket});\n\n    this.protocol.once('connect', function(){\n        logger.info('connected to %s:%s', host, port);\n        connectDeferred.resolve();\n    });\n\n    this.protocol.on('close', function(){\n        logger.info('disconnected from %s:%s', host, port);\n\n        // reject all remaining requests\n        for(var seq in self.requests){\n            process.domain = self.domains[seq];\n            self.requests[seq].reject(new Error('connection closed'));\n        }\n        self.requests = {};\n        self.domains = {};\n\n        // Server will not disconnect if the client process exit immediately\n        // So delay resolve promise\n        if(self.disconnectDeferred){\n            setTimeout(function(){\n                self.disconnectDeferred.resolve();\n            }, 1);\n        }\n        self.protocol = null;\n\n        self.emit('close');\n    });\n\n    this.protocol.on('msg', function(msg){\n        var request = self.requests[msg.seq];\n        if(!request){\n            return;\n        }\n\n        // restore saved domain\n        process.domain = self.domains[msg.seq];\n\n        if(!msg.err){\n            logger.info('%s:%s => %j', host, port, msg);\n            request.resolve(msg.data);\n        }\n        else{\n            logger.error('%s:%s => %j', host, port, msg);\n            request.reject(msg.err);\n        }\n        delete self.requests[msg.seq];\n        delete self.domains[msg.seq];\n    });\n\n    this.protocol.on('error', function(err){\n        if(!connectDeferred.isResolved()){\n            connectDeferred.reject(err);\n        }\n        // Reject all pending requests\n        Object.keys(self.requests).forEach(function(seq){\n            // restore saved domain\n            process.domain = self.domains[seq];\n            self.requests[seq].reject(err);\n\n            delete self.domains[seq];\n            delete self.requests[seq];\n        });\n    });\n\n    this.protocol.on('timeout', function(){\n        self.disconnect();\n    });\n\n    return connectDeferred.promise;\n};\n\nproto.disconnect = function(){\n    if(!this.protocol){\n        return;\n    }\n\n    this.disconnectDeferred = P.defer();\n    this.protocol.disconnect();\n\n    return this.disconnectDeferred.promise;\n};\n\nproto.request = function(connId, method, args){\n    if(!this.protocol){\n        throw new Error('not connected');\n    }\n\n    var seq = this.seq++;\n\n    var deferred = P.defer();\n    this.requests[seq] = deferred;\n\n    var msg = {\n        seq : seq,\n        connId : connId,\n        method : method,\n        args : args,\n    };\n\n    this.protocol.send(msg);\n\n    // save domain\n    this.domains[seq] = process.domain;\n\n    logger.info('%s:%s <= %j', this.protocol.socket.remoteAddress, this.protocol.socket.remotePort, msg);\n\n    return deferred.promise;\n};\n\nmodule.exports = Client;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/lib/protocol.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar P = require('bluebird');\nvar logger = require('memdb-logger').getLogger('memdb-client', __filename);\n\nvar Protocol = function(opts){\n    EventEmitter.call(this);\n\n    opts = opts || {};\n\n    this.socket = opts.socket;\n    this.socket.setEncoding('utf8');\n\n    this.remainLine = '';\n\n    var self = this;\n    this.socket.on('data', function(data){\n        // message is json encoded and splited by '\\n'\n        var lines = data.split('\\n');\n        for(var i=0; i<lines.length - 1; i++){\n            try{\n                var msg = '';\n                if(i === 0){\n                    msg = JSON.parse(self.remainLine + lines[i]);\n                    self.remainLine = '';\n                }\n                else{\n                    msg = JSON.parse(lines[i]);\n                }\n                self.emit('msg', msg);\n            }\n            catch(err){\n                logger.error(err.stack);\n            }\n        }\n        self.remainLine = lines[lines.length - 1];\n    });\n\n    this.socket.on('close', function(hadError){\n        self.emit('close', hadError);\n    });\n\n    this.socket.on('connect', function(){\n        self.emit('connect');\n    });\n\n    this.socket.on('error', function(err){\n        self.emit('error', err);\n    });\n\n    this.socket.on('timeout', function(){\n        self.emit('timeout');\n    });\n};\n\nutil.inherits(Protocol, EventEmitter);\n\nProtocol.prototype.send = function(msg){\n    var data = JSON.stringify(msg) + '\\n';\n\n    var ret = this.socket.write(data);\n    if(!ret){\n        logger.warn('socket.write return false');\n    }\n};\n\nProtocol.prototype.disconnect = function(){\n    this.socket.end();\n};\n\nmodule.exports = Protocol;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/lib/consts.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar exports = {};\n\nexports.collMethods = ['find', 'findOne', 'findById',\n                    'findReadOnly', 'findOneReadOnly', 'findByIdReadOnly',\n                    'insert', 'update', 'remove', 'lock', 'count'];\n\nexports.connMethods = ['commit', 'rollback', 'eval', 'info', 'resetCounter', 'flushBackend', '$unload', '$findReadOnly'];\n\nexports.version = require('../package').version;\n\nmodule.exports = exports;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/lib/autoconnection.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar _ = require('lodash');\nvar domain = require('domain');\nvar P = require('bluebird');\nvar Connection = require('./connection');\nvar AsyncLock = require('async-lock');\nvar consts = require('./consts');\nvar uuid = require('node-uuid');\nvar logger = require('memdb-logger').getLogger('memdb-client', __filename);\n\n// Max connections per shard (max concurrent transactions per shard)\nvar DEFAULT_MAX_CONNECTION = 32;\n// Idle time before close connection\nvar DEFAULT_CONNECTION_IDLE_TIMEOUT = 600 * 1000;\n// Max pending tasks per shard\nvar DEFAULT_MAX_PENDING_TASK = 2048;\n\nvar DEFAULT_RECONNECT_INTERVAL = 2000;\n\n// Use one connection per transaction\n// Route request to shards\nvar AutoConnection = function(opts){\n    opts = opts || {};\n\n    this.db = opts.db;\n\n    this.config = {\n        maxConnection : opts.maxConnection || DEFAULT_MAX_CONNECTION,\n        connectionIdleTimeout : opts.connectionIdleTimeout || DEFAULT_CONNECTION_IDLE_TIMEOUT,\n        maxPendingTask : opts.maxPendingTask || DEFAULT_MAX_PENDING_TASK,\n        reconnectInterval : opts.reconnectInterval || DEFAULT_RECONNECT_INTERVAL,\n\n        // allow concurrent request inside one connection, internal use only\n        concurrentInConnection : opts.concurrentInConnection || false,\n\n        // {shardId : {host : '127.0.0.1', port : 31017}}\n        shards : opts.shards || {},\n    };\n\n    if(this.config.concurrentInConnection){\n        this.config.maxConnection = 1;\n    }\n\n    var shardIds = Object.keys(this.config.shards);\n    if(shardIds.length === 0){\n        throw new Error('please specify opts.shards');\n    }\n\n    var shards = {};\n    shardIds.forEach(function(shardId){\n        shards[shardId] = {\n            connections : {}, // {connId : connection}\n            freeConnections : {}, // {connId : true}\n            connectionTimeouts : {}, // {connId : timeout}\n            pendingTasks : [],\n            reconnectInterval : null,\n        };\n    });\n    this.shards = shards;\n\n    this.openConnectionLock = new AsyncLock({Promise : P, maxPending : 10000});\n    this.collections = {};\n};\n\nvar proto = AutoConnection.prototype;\n\nproto.close = function(){\n    var self = this;\n    // Close all connections to all shards\n    return P.map(Object.keys(this.shards), function(shardId){\n        var shard = self.shards[shardId];\n\n        clearInterval(shard.reconnectInterval);\n        shard.reconnectInterval = null;\n\n        // reject all pending tasks\n        shard.pendingTasks.forEach(function(task){\n            task.deferred.reject(new Error('connection closed'));\n        });\n        shard.pendingTasks = [];\n\n        // close all connections\n        var connections = shard.connections;\n        return P.map(Object.keys(connections), function(connId){\n            var conn = connections[connId];\n            if(conn){\n                return conn.close();\n            }\n        });\n    })\n    .then(function(){\n        logger.info('autoConnection closed');\n    })\n    .catch(function(err){\n        logger.error(err.stack);\n    });\n};\n\nproto.openConnection = function(shardId){\n    var self = this;\n\n    return this.openConnectionLock.acquire(shardId, function(){\n        var shard = self._shard(shardId);\n        if(Object.keys(shard.connections).length >= self.config.maxConnection){\n            return;\n        }\n\n        var conn = new Connection({\n                                host : self.config.shards[shardId].host,\n                                port : self.config.shards[shardId].port,\n                                idleTimeout : self.config.connectionIdleTimeout\n                            });\n\n        return conn.connect()\n        .then(function(connId){\n            clearInterval(shard.reconnectInterval);\n            shard.reconnectInterval = null;\n\n            shard.connections[connId] = conn;\n\n            logger.info('[shard:%s][conn:%s] open connection', shardId, connId);\n\n            shard.freeConnections[connId] = true;\n\n            conn.on('close', function(){\n                logger.info('[shard:%s][conn:%s] connection closed', shardId, connId);\n                delete shard.connections[connId];\n                delete shard.freeConnections[connId];\n            });\n\n            setImmediate(function(){\n                return self._runTask(shardId);\n            });\n        }, function(e){\n            if(!shard.reconnectInterval){\n                shard.reconnectInterval = setInterval(function(){\n                    return self.openConnection(shardId);\n                }, self.config.reconnectInterval);\n            }\n            logger.error(e.stack);\n\n            if(Object.keys(shard.connections).length === 0){\n                logger.error('No connection available for shard %s', shardId);\n\n                // no available connection, reject all pending tasks\n                shard.pendingTasks.forEach(function(task){\n                    task.deferred.reject(e);\n                });\n                shard.pendingTasks = [];\n            }\n        });\n    })\n    .catch(function(e){\n        logger.error(e.stack);\n    });\n};\n\nproto._task = function(method, args, shardId){\n    var deferred = P.defer();\n    try{\n        if(!shardId){\n            var shardIds = Object.keys(this.shards);\n            if(shardIds.length > 1){\n                throw new Error('You must specify shardId');\n            }\n            shardId = shardIds[0];\n        }\n\n        var shard = this._shard(shardId);\n\n        if(shard.pendingTasks.length >= this.config.maxPendingTask){\n            throw new Error('Too much pending tasks');\n        }\n\n        shard.pendingTasks.push({\n            method : method,\n            args : args,\n            deferred : deferred\n        });\n\n        var self = this;\n        setImmediate(function(){\n            return self._runTask(shardId);\n        });\n    }\n    catch(err){\n        deferred.reject(err);\n    }\n    finally{\n        return deferred.promise;\n    }\n};\n\nproto._runTask = function(shardId){\n    var self = this;\n    var shard = this._shard(shardId);\n\n    if(shard.pendingTasks.length === 0){\n        return;\n    }\n\n    var connIds = Object.keys(shard.freeConnections);\n    if(connIds.length === 0){\n        return this.openConnection(shardId);\n    }\n\n    var connId = connIds[0];\n    var conn = shard.connections[connId];\n    if(!this.config.concurrentInConnection){\n        delete shard.freeConnections[connId];\n    }\n\n    var task = shard.pendingTasks.shift();\n\n    if(this.config.concurrentInConnection){\n        // start run next before current task finish\n        setImmediate(function(){\n            self._runTask(shardId);\n        });\n    }\n\n    return P.try(function(){\n        if(task.method === '__t'){\n            var func = task.args[0];\n            return self._runTransaction(func, conn, shardId);\n        }\n        else{\n            var method = conn[task.method];\n            if(typeof(method) !== 'function'){\n                throw new Error('invalid method - ' + task.method);\n            }\n            return method.apply(conn, task.args);\n        }\n    })\n    .then(function(ret){\n        task.deferred.resolve(ret);\n    }, function(err){\n        task.deferred.reject(err);\n    })\n    .finally(function(){\n        if(shard.connections.hasOwnProperty(connId)){\n            shard.freeConnections[connId] = true;\n        }\n\n        setImmediate(function(){\n            self._runTask(shardId);\n        });\n    })\n    .catch(function(e){\n        logger.error(e.stack);\n    });\n};\n\nproto._runTransaction = function(func, conn, shardId){\n    if(typeof(func) !== 'function'){\n        throw new Error('Function is required');\n    }\n\n    var deferred = P.defer();\n\n    var scope = domain.create();\n    scope.__memdb__ = {shard: shardId, conn: conn._connId, trans : uuid.v4()};\n\n    var self = this;\n    scope.run(function(){\n        logger.info('[shard:%s][conn:%s] transaction start', shardId, conn._connId);\n\n        var startTick = Date.now();\n\n        return P.try(function(){\n            return func();\n        })\n        .then(function(ret){\n            return conn.commit()\n            .then(function(){\n                logger.info('[shard:%s][conn:%s] transaction done (%sms)', shardId, conn._connId, Date.now() - startTick);\n                delete scope.__memdb__;\n                deferred.resolve(ret);\n            });\n        }, function(err){\n            return conn.rollback()\n            .then(function(){\n                logger.error('[shard:%s][conn:%s] transaction error %s', shardId, conn._connId, err.stack);\n                delete scope.__memdb__;\n                deferred.reject(err);\n            });\n        })\n        .catch(function(e){\n            logger.error(e.stack);\n            deferred.reject(e);\n        });\n    });\n\n    return deferred.promise;\n};\n\n// Get connection from current scope\nproto._connection = function(){\n    var info = process.domain && process.domain.__memdb__;\n    if(!info){\n        throw new Error('You are not in any transaction scope');\n    }\n    var shard = this._shard(info.shard);\n    var conn = shard.connections[info.conn];\n    if(!conn){\n        throw new Error('connection ' + info.conn + ' not exist');\n    }\n    return conn;\n};\n\nproto._shard = function(shardId){\n    var shard = this.shards[shardId];\n    if(!shard){\n        throw new Error('shard ' + shardId + ' not exist');\n    }\n    return shard;\n};\n\nproto.collection = function(name){\n    var self = this;\n    if(!this.collections[name]){\n        var collection = {};\n        // Method must be called inside transaction\n        consts.collMethods.forEach(function(method){\n            collection[method] = function(){\n                var conn = self._connection();\n                var args = [name].concat([].slice.call(arguments));\n                return conn[method].apply(conn, args);\n            };\n        });\n\n        this.collections[name] = collection;\n    }\n    return this.collections[name];\n};\n\nconsts.connMethods.forEach(function(method){\n    if(method === 'commit' || method === 'rollback'){\n        return;\n    }\n    // Methods not bind to transaction\n    proto[method] = function(){\n        var shardId = arguments[0];\n        var args = [].slice.call(arguments, 1);\n        return this._task(method, args, shardId);\n    };\n});\n\nproto.transaction = function(func, shardId){\n    return this._task('__t', [func], shardId);\n};\n\nmodule.exports = AutoConnection;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/gruntfile.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nmodule.exports = function(grunt) {\n    // Unified Watch Object\n    var watchFiles = {\n        libJS: ['gruntfile.js', 'index.js', 'app/**/*.js', 'bin/**/*.js', 'lib/**/*.js'],\n        testJS: ['test/app/*.js', 'test/bin/*.js', 'test/lib/*.js', 'test/perf.js'],\n    };\n\n    // Project Configuration\n    grunt.initConfig({\n        pkg: grunt.file.readJSON('package.json'),\n        env: {\n            test: {\n                NODE_ENV: 'test'\n            }\n        },\n        watch: {\n            libJS: {\n                files: watchFiles.libJS.concat(watchFiles.testJS),\n                tasks: ['jshint'],\n                options: {\n                    livereload: true\n                }\n            }\n        },\n        jshint: {\n            all: {\n                src: watchFiles.libJS.concat(watchFiles.testJS),\n                options: {\n                    jshintrc: true\n                }\n            }\n        },\n        mochaTest: {\n            test : {\n                src: watchFiles.testJS,\n                options : {\n                    reporter: 'spec',\n                    timeout: 10000,\n                    require: 'test/blanket'\n                }\n            },\n            // coverage: {\n            //     src: watchFiles.testJS,\n            //     options : {\n            //         reporter: 'html-cov',\n            //         quiet: true,\n            //         captureFile: 'coverage.html'\n            //     }\n            // }\n        },\n        clean: {\n            'coverage.html' : {\n                src: ['coverage.html']\n            }\n        },\n        nodemon: {\n            dev: {\n                script: 'bin/memdbd',\n                options: {\n                    args : ['--conf=./test/memdb.conf.js', '--shard=s1'],\n                    nodeArgs: ['--debug'],\n                    ext: 'js,html',\n                    watch: watchFiles.serverJS\n                }\n            }\n        },\n        'node-inspector': {\n            custom: {\n                options: {\n                    'web-port': 8088,\n                    'web-host': 'localhost',\n                    'debug-port': 5858,\n                    'save-live-edit': true,\n                    'no-preload': true,\n                    'stack-trace-limit': 50,\n                    'hidden': []\n                }\n            }\n        },\n        concurrent: {\n            default: ['nodemon', 'watch'],\n            debug: ['nodemon', 'watch', 'node-inspector'],\n            options: {\n                logConcurrentOutput: true,\n                limit: 10\n            }\n        },\n    });\n\n    // Load NPM tasks\n    require('load-grunt-tasks')(grunt);\n\n    // Making grunt default to force in order not to break the project.\n    grunt.option('force', true);\n\n    // Lint task(s).\n    grunt.registerTask('lint', ['jshint']);\n\n    // Test task.\n    grunt.registerTask('test', ['clean', 'lint', 'env:test', 'mochaTest']);\n\n    // Run server\n    grunt.registerTask('default', ['clean', 'lint', 'concurrent:default']);\n\n    // Debug server\n    grunt.registerTask('debug', ['clean', 'lint', 'concurrent:debug']);\n};\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/memdb.conf.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n/*\n * MemDB config template\n *\n * Please modify it on your needs\n *\n * This is plain javascript, you can add any js code here, just export the config\n *\n * DO NOT modify it when any memdb shard is running\n */\n\nmodule.exports = {\n    // *** global settings for all shards ***\n\n    // Global backend storage, all shards must connect to the same mongodb (or mongodb cluster)\n    backend : {\n        engine : 'mongodb', // should be 'mongodb'\n        url : 'mongodb://localhost/memdb', // mongodb connect string\n    },\n\n    // Global locking redis, all shards must connect to the same redis (or redis cluster)\n    locking : {\n        host : '127.0.0.1',\n        port : 6379,\n        db : 0,\n    },\n\n    // Data replication redis, one redis instance for each shard\n    // You can override this in shard settings to choice different slave for each shard\n    slave : {\n        host : '127.0.0.1',\n        port : 6379,\n        db : 0,\n    },\n\n    // Log settings\n    log : {\n        // Log file path, default ~/.memdb\n        path : process.env.HOME + '/.memdb/log',\n        // Log Level (one of 'ALL', 'TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL', 'OFF')\n        // Please set to WARN on production\n        level : 'WARN',\n    },\n\n    // Promise settings\n    promise : {\n        // Enable long stack trace, disable it on production\n        longStackTraces : false,\n    },\n\n    // user for memdbcluster ssh login, default current user\n    // when start using memdbcluster, make sure you have ssh permission (without password) on all servers,\n    // and the memdb version, install folder, config files are all the same in all servers\n    user : process.env.USER,\n\n    // Collection settings for index\n    /* modify it on your need\n    collections : {\n        // Collection name\n        player : {\n            indexes : [\n                {\n                    // Index keys\n                    keys : ['areaId'],\n                    // Value exclude from index. Values like '', -1 occurs too often, which can make the index too large.\n                    // 'null' or 'undefined' is ignored by default.\n                    valueIgnore : {\n                        areaId : ['', -1],\n                    },\n                },\n                {\n                    // Index keys (compound index)\n                    keys : ['deviceType', 'deviceId'],\n                    // Unique constraint for the index\n                    unique : true,\n                },\n            ]\n        }\n    },\n    */\n\n\n    // *** Shard specific settings ***\n\n    // This will override global settings on specifid shard\n    shards : {\n        // shardId\n        s1 : {\n            // server IP\n            host : '127.0.0.1',\n            // listen port\n            port : 31017,\n\n            // bind Ip\n            // DO NOT bind to localhost when deploy on multiple servers\n            // make sure servers can communicate with each other\n            bind : '0.0.0.0',\n\n            // Add any shard specific settings here\n            // slave : {\n            //     host : '127.0.0.1',\n            //     port : 6379,\n            //     db : 1,\n            // },\n        },\n\n        // Add more shards\n        s2 : {\n            host : '127.0.0.1',\n            port : 31018,\n        },\n        // s3 : {\n        //     host : '127.0.0.1',\n        //     port : 31019,\n        // },\n        // s4 : {\n        //     host : '127.0.0.1',\n        //     port : 31020,\n        // },\n    },\n\n\n    // *** additional settings ***\n    // These settings are unstable and may change in later version\n\n    // Delay for flush changes to backend storage\n    // Set it to large value to improve performance if the data delay in backend storage is not an issue.\n    // persistentDelay : 600 * 1000, // number in ms, default 10 min. 0 indicates never\n\n    // Idle time before document is removed from memory.\n    // Larger value can improve performance but use more memory.\n    // Set it to large value if the documents accessed via this shard is limited.\n    // Do not access too many different documents in a short time, which may exhault memory and trigger heavy GC operation.\n    // idleTimeout : 1800 * 1000, // number in ms, default 30 min. 0 indicates never\n\n    // GC will be triggered when memory usage reach this limit\n    // GC can be very heavy, please adjust idleTimeout to avoid GC.\n    // memoryLimit : 1024, // number in MB, default 1024\n\n    // Disable redis replica, DO NOT turn on this in production.\n    // disableSlave : false, // default false\n\n    // Slow query time\n    // slowQuery : 2000, // number in ms. default 2000\n\n    // Turn on heapdump module (https://www.npmjs.com/package/heapdump)\n    // heapdump : false, // default false\n};\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/backendlocker.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar P = require('bluebird');\nvar Logger = require('memdb-logger');\nvar util = require('util');\nvar redis = P.promisifyAll(require('redis'));\n\nvar BackendLocker = function(opts){\n    opts = opts || {};\n\n    this.shardId = opts.shardId;\n    this.config = {\n        host : opts.host || '127.0.0.1',\n        port : opts.port || 6379,\n        db : opts.db || 0,\n        options : opts.options || {},\n        prefix : opts.prefix || 'bl$',\n        heartbeatPrefix  : opts.heartbeatPrefix || 'hb$',\n        heartbeatTimeout : opts.heartbeatTimeout,\n        heartbeatInterval : opts.heartbeatInterval,\n    };\n\n    this.client = null;\n    this.heartbeatInterval = null;\n\n    this.logger = Logger.getLogger('memdb', __filename, 'shard:' + this.shardId);\n};\n\nvar proto = BackendLocker.prototype;\n\nproto.start = function(){\n    return P.bind(this)\n    .then(function(){\n        this.client = redis.createClient(this.config.port, this.config.host, {retry_max_delay : 10 * 1000, enable_offline_queue : true});\n        var self = this;\n        this.client.on('error', function(err){\n            self.logger.error(err.stack);\n        });\n        return this.client.selectAsync(this.config.db);\n    })\n    .then(function(){\n        if(this.shardId){\n            return this.isAlive()\n            .then(function(ret){\n                if(ret){\n                    throw new Error('Current shard is running in some other process');\n                }\n            });\n        }\n    })\n    .then(function(){\n        if(this.shardId && this.config.heartbeatInterval > 0){\n            this.heartbeatInterval = setInterval(this.heartbeat.bind(this), this.config.heartbeatInterval);\n            return this.heartbeat();\n        }\n    })\n    .then(function(){\n        this.logger.info('backendLocker started %s:%s:%s', this.config.host, this.config.port, this.config.db);\n    });\n};\n\nproto.stop = function(){\n    return P.bind(this)\n    .then(function(){\n        clearInterval(this.heartbeatInterval);\n        return this.clearHeartbeat();\n    })\n    .then(function(){\n        return this.client.quitAsync();\n    })\n    .then(function(){\n        this.logger.info('backendLocker stoped');\n    });\n};\n\nproto.tryLock = function(docId, shardId){\n    this.logger.debug('tryLock %s', docId);\n\n    var self = this;\n    return this.client.setnxAsync(this._docKey(docId), shardId || this.shardId)\n    .then(function(ret){\n        if(ret === 1){\n            self.logger.debug('locked %s', docId);\n            return true;\n        }\n        else{\n            return false;\n        }\n    });\n};\n\nproto.getHolderId = function(docId){\n    return this.client.getAsync(this._docKey(docId));\n};\n\nproto.isHeld = function(docId, shardId){\n    var self = this;\n    return this.getHolderId(docId)\n    .then(function(ret){\n        return ret === (shardId || self.shardId);\n    });\n};\n\n// concurrency safe between shards\n// not concurrency safe in same shard\nproto.unlock = function(docId){\n    this.logger.debug('unlock %s', docId);\n\n    var self = this;\n    return this.isHeld(docId)\n    .then(function(held){\n        if(held){\n            return self.client.delAsync(self._docKey(docId));\n        }\n    });\n};\n\nproto.heartbeat = function(){\n    var timeout = Math.floor(this.config.heartbeatTimeout / 1000);\n    if(timeout <= 0){\n        timeout = 1;\n    }\n\n    var self = this;\n    return this.client.setexAsync(this._heartbeatKey(this.shardId), timeout, 1)\n    .then(function(){\n        self.logger.debug('heartbeat');\n    })\n    .catch(function(err){\n        self.logger.error(err.stack);\n    });\n};\n\nproto.clearHeartbeat = function(){\n    return this.client.delAsync(this._heartbeatKey(this.shardId));\n};\n\nproto.isAlive = function(shardId){\n    return this.client.existsAsync(this._heartbeatKey(shardId || this.shardId))\n    .then(function(ret){\n        return !!ret;\n    });\n};\n\nproto.getActiveShards = function(){\n    var prefix = this.config.heartbeatPrefix;\n    return this.client.keysAsync(prefix + '*')\n    .then(function(keys){\n        return keys.map(function(key){\n            return key.slice(prefix.length);\n        });\n    });\n};\n\nproto._docKey = function(docId){\n    return this.config.prefix + docId;\n};\n\nproto._heartbeatKey = function(shardId){\n    return this.config.heartbeatPrefix + shardId;\n};\n\nmodule.exports = BackendLocker;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/collection.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar P = require('bluebird');\nvar Logger = require('memdb-logger');\nvar util = require('util');\nvar utils = require('./utils');\nvar EventEmitter = require('events').EventEmitter;\n\nvar DEFAULT_MAX_COLLISION = 10000;\n\nvar Collection = function(opts){\n    opts = opts || {};\n\n    this.name = opts.name;\n    this._checkName(this.name);\n\n    this.shard = opts.shard;\n    this.conn = opts.conn;\n    this.config = opts.config || {};\n    this.config.maxCollision = this.config.maxCollision || DEFAULT_MAX_COLLISION;\n\n    // {indexKey : {indexValue : {id1 : 1, id2 : -1}}}\n    this.changedIndexes = utils.forceHashMap();\n\n    this.pendingIndexTasks = utils.forceHashMap(); //{id, [Promise]}\n\n    this.updateIndexEvent = 'updateIndex$' + this.name + '$' + this.conn._id;\n    this.shard.on(this.updateIndexEvent, this.onUpdateIndex.bind(this));\n\n    this.logger = Logger.getLogger('memdb', __filename, 'shard:' + this.shard._id);\n\n    EventEmitter.call(this);\n};\n\nutil.inherits(Collection, EventEmitter);\n\nvar proto = Collection.prototype;\n\nproto.close = function(){\n    this.shard.removeListener(this.updateIndexEvent, this.onUpdateIndex);\n};\n\nproto.insert = function(docs){\n    if(!Array.isArray(docs)){\n        return this._insertById(docs && docs._id, docs);\n    }\n\n    var self = this;\n    return P.mapSeries(docs, function(doc){ //disable concurrent to avoid race condition\n        return self._insertById(doc && doc._id, doc);\n    });\n};\n\nproto._insertById = function(id, doc){\n    if(!utils.isDict(doc)){\n        throw new Error('doc must be a dictionary');\n    }\n\n    if(id === null || id === undefined){\n        id = utils.uuid();\n    }\n    id = this._checkId(id);\n    doc._id = id;\n\n    var self = this;\n    return P.try(function(){\n        return self.lock(id);\n    })\n    .then(function(){\n        return self.shard.insert(self.conn._id, self._key(id), doc);\n    })\n    .then(function(){\n        return self._finishIndexTasks(id);\n    })\n    .thenReturn(id);\n};\n\nproto.find = function(query, fields, opts){\n    if(typeof(query) === 'number' || typeof(query) === 'string'){\n        return this.findById(query, fields, opts);\n    }\n\n    if(!utils.isDict(query)){\n        throw new Error('invalid query');\n    }\n\n    if(query.hasOwnProperty('_id')){\n        return this.findById(query._id, fields, opts)\n        .then(function(doc){\n            if(!doc){\n                return [];\n            }\n            return [doc];\n        });\n    }\n\n    var keys = Object.keys(query).sort();\n    if(keys.length === 0){\n        throw new Error('You must specify query key');\n    }\n\n    var indexKey = JSON.stringify(keys);\n\n    var indexConfig = this.config.indexes && this.config.indexes[indexKey];\n    if(!indexConfig){\n        throw new Error('No index configured for keys - ' + indexKey);\n    }\n\n    var valueIgnore = indexConfig.valueIgnore || {};\n    var values = keys.map(function(key){\n        var value = query[key];\n        if(value === null || value === undefined){\n            throw new Error('query value can not be null or undefined');\n        }\n        var ignores = valueIgnore[key] || [];\n        if(ignores.indexOf(value) !== -1){\n            throw new Error('value ' + value + ' for key ' + key + ' is ignored in index');\n        }\n        return value;\n    });\n    var indexValue = JSON.stringify(values);\n\n    return this._findByIndex(indexKey, indexValue, fields, opts);\n};\n\nproto.findOne = function(query, fields, opts){\n    opts = opts || {};\n    opts.limit = 1;\n    return this.find(query, fields, opts)\n    .then(function(docs){\n        if(!Array.isArray(docs)){\n            return docs;\n        }\n        if(docs.length === 0){\n            return null;\n        }\n        return docs[0];\n    });\n};\n\nproto.findById = function(id, fields, opts){\n    id = this._checkId(id);\n\n    var self = this;\n    return P.try(function(){\n        if(opts && opts.readonly){\n            return self.shard.findReadOnly(self.conn._id, self._key(id), fields);\n        }\n\n        return P.try(function(){\n            if(opts && opts.nolock){\n                return;\n            }\n            return self.lock(id);\n        })\n        .then(function(){\n            return self.shard.find(self.conn._id, self._key(id), fields, opts);\n        });\n    });\n};\n\nproto.findReadOnly = function(query, fields, opts){\n    opts = opts || {};\n    opts.readonly = true;\n    return this.find(query, fields, opts);\n};\n\nproto.findOneReadOnly = function(query, fields, opts){\n    opts = opts || {};\n    opts.readonly = true;\n    return this.findOne(query, fields, opts);\n};\n\nproto.findByIdReadOnly = function(id, fields, opts){\n    opts = opts || {};\n    opts.readonly = true;\n    return this.findById(id, fields, opts);\n};\n\nproto.count = function(query, opts){\n    opts = opts || {};\n    opts.count = true;\n    var self = this;\n    return P.try(function(){\n        return self.find(query, null, opts);\n    })\n    .then(function(ret){\n        if(typeof(ret) === 'number'){\n            return ret;\n        }\n        else if(Array.isArray(ret)){\n            return ret.length;\n        }\n        else if(!ret){\n            return 0;\n        }\n        throw new Error('Unexpected find result - ' + ret);\n    });\n};\n\nproto._findByIndex = function(indexKey, indexValue, fields, opts){\n    opts = opts || {};\n    var self = this;\n\n    var indexCollection = this.conn.getCollection(this._indexCollectionName(indexKey), true);\n\n    var nolock = opts.nolock;\n\n    return P.try(function(){\n        opts.nolock = true; // force not using lock\n        return indexCollection.findById(indexValue, 'format ids', opts);\n    })\n    .then(function(doc){\n        opts.nolock = nolock; // restore param\n\n        var ids = utils.forceHashMap();\n\n        if(doc){\n            doc.ids.forEach(function(id){\n                ids[id] = 1;\n            });\n        }\n\n        var changedIds = (self.changedIndexes[indexKey] && self.changedIndexes[indexKey][indexValue]) || {};\n        for(var id in changedIds){\n            if(changedIds[id] === 1){\n                ids[id] = 1;\n            }\n            else{\n                delete ids[id];\n            }\n        }\n\n        ids = Object.keys(ids);\n        if(opts && opts.count){ // return count only\n            return ids.length;\n        }\n        if(opts && opts.limit){\n            ids = ids.slice(0, opts.limit);\n        }\n\n        var docs = [];\n        ids.sort(); // keep id in order, avoid deadlock\n        return P.each(ids, function(id){\n            return self.findById(id, fields, opts)\n            .then(function(doc){\n                // WARN: This is possible that doc is null due to index collection is not locked\n                if(!!doc){\n                    docs.push(doc);\n                }\n            });\n        })\n        .thenReturn(docs);\n    });\n};\n\nproto.update = function(query, modifier, opts){\n    opts = opts || {};\n    var self = this;\n\n    return P.try(function(){\n        return self.find(query, '_id');\n    })\n    .then(function(ret){\n        if(!ret || ret.length === 0){\n            if(!opts.upsert){\n                return 0;\n            }\n            // upsert\n            if(typeof(query) === 'string' || typeof(query) === 'number'){\n                query = {_id : query};\n            }\n            return self.insert(query)\n            .then(function(id){\n                return self._updateById(id, modifier, opts);\n            })\n            .thenReturn(1);\n        }\n\n        if(!Array.isArray(ret)){\n            return self._updateById(ret._id, modifier, opts)\n            .thenReturn(1);\n        }\n        return P.each(ret, function(doc){\n            return self._updateById(doc._id, modifier, opts);\n        })\n        .thenReturn(ret.length);\n    });\n};\n\nproto._updateById = function(id, modifier, opts){\n    id = this._checkId(id);\n\n    var self = this;\n    return P.try(function(){\n        return self.shard.update(self.conn._id, self._key(id), modifier, opts);\n    })\n    .then(function(){\n        return self._finishIndexTasks(id);\n    });\n};\n\nproto.remove = function(query, opts){\n    var self = this;\n    return P.try(function(){\n        return self.find(query, '_id');\n    })\n    .then(function(ret){\n        if(!ret || ret.length === 0){\n            return 0;\n        }\n        if(!Array.isArray(ret)){\n            return self._removeById(ret._id, opts)\n            .thenReturn(1);\n        }\n        return P.each(ret, function(doc){\n            return self._removeById(doc._id, opts);\n        })\n        .thenReturn(ret.length);\n    });\n};\n\nproto._removeById = function(id, opts){\n    id = this._checkId(id);\n\n    var self = this;\n    return P.try(function(){\n        return self.shard.remove(self.conn._id, self._key(id), opts);\n    })\n    .then(function(){\n        return self._finishIndexTasks(id);\n    });\n};\n\nproto.lock = function(id){\n    id = this._checkId(id);\n    if(this.shard.isLocked(this.conn._id, this._key(id))){\n        return;\n    }\n\n    var self = this;\n    return this.shard.lock(this.conn._id, this._key(id))\n    .then(function(ret){\n        self.emit('lock', id);\n        return ret;\n    });\n};\n\nproto.onUpdateIndex = function(id, indexKey, oldValue, newValue){\n    this.logger.debug('onUpdateIndex(%s, %s, %s, %s)', id, indexKey, oldValue, newValue);\n\n    var self = this;\n    var promise = P.try(function(){\n\n        var config = self.config.indexes[indexKey];\n        if(!config){\n            throw new Error('index - ' + indexKey + ' not configured');\n        }\n        if(!self.changedIndexes[indexKey]){\n            self.changedIndexes[indexKey] = utils.forceHashMap();\n        }\n\n        var changedIndex = self.changedIndexes[indexKey];\n\n        if(oldValue !== null){\n            if(!changedIndex[oldValue]){\n                changedIndex[oldValue] = utils.forceHashMap();\n            }\n            if(changedIndex[oldValue][id] === 1){\n                delete changedIndex[oldValue][id];\n            }\n            else{\n                changedIndex[oldValue][id] = -1;\n            }\n        }\n        if(newValue !== null){\n            if(!changedIndex[newValue]){\n                changedIndex[newValue] = utils.forceHashMap();\n            }\n            if(changedIndex[newValue][id] === -1){\n                delete changedIndex[oldValue][id];\n            }\n            else{\n                changedIndex[newValue][id] = 1;\n            }\n        }\n\n        if(!config.unique){\n            return;\n        }\n\n        return P.try(function(){\n            if(oldValue !== null){\n                return self.commitOneIndex(indexKey, oldValue, changedIndex[oldValue], config)\n                .then(function(){\n                    delete changedIndex[oldValue];\n                });\n            }\n        })\n        .then(function(){\n            if(newValue !== null){\n                return self.commitOneIndex(indexKey, newValue, changedIndex[newValue], config)\n                .then(function(){\n                    delete changedIndex[newValue];\n                });\n            }\n        });\n    });\n\n    if(!this.pendingIndexTasks[id]){\n        this.pendingIndexTasks[id] = [];\n    }\n    this.pendingIndexTasks[id].push(promise);\n};\n\nproto.commitIndex = function(){\n    var self = this;\n\n    // must update in sorted order to avoid dead lock\n    return P.each(Object.keys(this.changedIndexes).sort(), function(indexKey){\n        var changedIndex = self.changedIndexes[indexKey];\n        var config = self.config.indexes[indexKey];\n\n        return P.each(Object.keys(changedIndex).sort(), function(indexValue){\n            var changedIds = changedIndex[indexValue];\n\n            return self.commitOneIndex(indexKey, indexValue, changedIds, config);\n        });\n    })\n    .then(function(){\n        self.changedIndexes = utils.forceHashMap();\n    });\n};\n\nproto.rollbackIndex = function(){\n    this.changedIndexes = utils.forceHashMap();\n};\n\n// indexKey: json encoded sorted fields array\n// indexValue: json encoded sorted fields value\nproto.commitOneIndex = function(indexKey, indexValue, changedIds, config){\n\n    var indexCollection = this.conn.getCollection(this._indexCollectionName(indexKey), true);\n\n    var modifier = {$pushAll : {ids : []}, $pullAll : {ids : []}};\n\n    var countDelta = 0;\n    for(var id in changedIds){\n        if(changedIds[id] === 1){\n            modifier.$pushAll.ids.push(id);\n            countDelta++;\n        }\n        else{\n            modifier.$pullAll.ids.push(id);\n            countDelta--;\n        }\n    }\n\n    var self = this;\n    return P.try(function(){\n        return indexCollection.find(indexValue, 'ids');\n    })\n    .then(function(ret){\n        var oldCount = ret ? ret.ids.length : 0;\n\n        var newCount = oldCount + countDelta;\n        if(config.unique && newCount > 1){\n            throw new Error('duplicate value - ' + indexValue + ' for unique index - ' + indexKey);\n        }\n        if(newCount > config.maxCollision){\n            throw new Error('too many documents have value - ' + indexValue + ' for index - ' + indexKey);\n        }\n\n        if(newCount > 0){\n            return indexCollection.update(indexValue, modifier, {upsert : true});\n        }\n        else if(newCount === 0){\n            return indexCollection.remove(indexValue);\n        }\n        else{\n            throw new Error(util.format('index corrupted: %s %s, please rebuild index', self.name, indexKey));\n        }\n    });\n};\n\nproto._finishIndexTasks = function(id){\n    if(!this.pendingIndexTasks[id]){\n        return;\n    }\n    // Save domain\n    var d = process.domain;\n    var self = this;\n    return P.each(self.pendingIndexTasks[id], function(promise){\n        return promise;\n    })\n    .finally(function(){\n        delete self.pendingIndexTasks[id];\n        // Restore domain\n        process.domain = d;\n    });\n};\n\n// 'index.name.key1.key2'\nproto._indexCollectionName = function(indexKey){\n    var keys = JSON.parse(indexKey).map(function(key){\n        return utils.escapeField(key);\n    });\n    return 'index.' + utils.escapeField(this.name) + '.' + keys.join('.');\n};\n\nproto._key = function(id){\n    return this.name + '$' + id;\n};\n\nproto._checkId = function(id){\n    if(typeof(id) === 'string'){\n        return id;\n    }\n    else if(typeof(id) === 'number'){\n        return id.toString();\n    }\n    throw new Error('id must be number or string');\n};\n\n//http://docs.mongodb.org/manual/reference/limits/#Restriction-on-Collection-Names\nproto._checkName = function(name){\n    if(!name){\n        throw new Error('Collection name can not empty');\n    }\n    if(typeof(name) !== 'string'){\n        throw new Error('Collection name must be string');\n    }\n    if(name.indexOf('$') !== -1){\n        throw new Error('Collection name can not contain \"$\"');\n    }\n    if(name.indexOf('system.') === 0){\n        throw new Error('Collection name can not begin with \"system.\"');\n    }\n};\n\nmodule.exports = Collection;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/utils.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar _ = require('lodash');\nvar util = require('util');\nvar P = require('bluebird');\nvar child_process = require('child_process');\nvar uuid = require('node-uuid');\n\n// Add some usefull promise methods\nexports.extendPromise = function(P){\n    // This is designed for large array\n    // The original map with concurrency option does not release memory\n    P.mapLimit = function(items, fn, limit){\n        if(!limit){\n            limit = 1000;\n        }\n        var groups = [];\n        var group = [];\n        items.forEach(function(item){\n            group.push(item);\n            if(group.length >= limit){\n                groups.push(group);\n                group = [];\n            }\n        });\n        if(group.length > 0){\n            groups.push(group);\n        }\n\n        var results = [];\n        var promise = P.resolve();\n        groups.forEach(function(group){\n            promise = promise.then(function(){\n                return P.map(group, fn)\n                .then(function(ret){\n                    ret.forEach(function(item){\n                        results.push(item);\n                    });\n                });\n            });\n        });\n        return promise.thenReturn(results);\n    };\n\n    P.mapSeries = function(items, fn){\n        var results = [];\n        return P.each(items, function(item){\n            return P.try(function(){\n                return fn(item);\n            })\n            .then(function(ret){\n                results.push(ret);\n            });\n        })\n        .thenReturn(results);\n    };\n};\n\nexports.uuid = function(){\n    return uuid.v4();\n};\n\nexports.isEmpty = function(obj){\n    for(var key in obj){\n        return false;\n    }\n    return true;\n};\n\nexports.getObjPath = function(obj, path){\n    var current = obj;\n    path.split('.').forEach(function(field){\n        if(!!current){\n            current = current[field];\n        }\n    });\n    return current;\n};\n\nexports.setObjPath = function(obj, path, value){\n    if(typeof(obj) !== 'object'){\n        throw new Error('not object');\n    }\n    var current = obj;\n    var fields = path.split('.');\n    var finalField = fields.pop();\n    fields.forEach(function(field){\n        if(!current.hasOwnProperty(field)){\n            current[field] = {};\n        }\n        current = current[field];\n        if(typeof(current) !== 'object'){\n            throw new Error('field ' + path + ' exists and not a object');\n        }\n    });\n    current[finalField] = value;\n};\n\nexports.deleteObjPath = function(obj, path){\n    if(typeof(obj) !== 'object'){\n        throw new Error('not object');\n    }\n    var current = obj;\n    var fields = path.split('.');\n    var finalField = fields.pop();\n    fields.forEach(function(field){\n        if(!!current){\n            current = current[field];\n        }\n    });\n    if(current !== undefined){\n        delete current[finalField];\n    }\n};\n\nexports.clone = function(obj){\n    return JSON.parse(JSON.stringify(obj));\n};\n\nexports.isDict = function(obj){\n    return typeof(obj) === 'object' && obj !== null && !Array.isArray(obj);\n};\n\n// escape '$' and '.' in field name\n// '$abc.def\\\\g' => '\\\\u0024abc\\\\u002edef\\\\\\\\g'\nexports.escapeField = function(str){\n    return str.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\u0024').replace(/\\./g, '\\\\u002e');\n};\n\nexports.unescapeField = function(str){\n    return str.replace(/\\\\u002e/g, '.').replace(/\\\\u0024/g, '$').replace(/\\\\\\\\/g, '\\\\');\n};\n\n// Async foreach for mongo's cursor\nexports.mongoForEach = function(itor, func){\n    var deferred = P.defer();\n\n    var next = function(err){\n        if(err){\n            return deferred.reject(err);\n        }\n        // async iterator with .next(cb)\n        itor.next(function(err, value){\n            if(err){\n                return deferred.reject(err);\n            }\n            if(value === null){\n                return deferred.resolve();\n            }\n            P.try(function(){\n                return func(value);\n            })\n            .nodeify(next);\n        });\n    };\n    next();\n\n    return deferred.promise;\n};\n\nexports.remoteExec = function(ip, cmd, opts){\n    ip = ip || '127.0.0.1';\n    opts = opts || {};\n    var user = opts.user || process.env.USER;\n    var successCodes = opts.successCodes || [0];\n\n    var child = null;\n    // localhost with current user\n    if((ip === '127.0.0.1' || ip.toLowerCase() === 'localhost') && user === process.env.USER){\n        child = child_process.spawn('bash', ['-c', cmd]);\n    }\n    // run remote via ssh\n    else{\n        child = child_process.spawn('ssh', ['-o StrictHostKeyChecking=no', user + '@' + ip, 'bash -c \\'' + cmd + '\\'']);\n    }\n\n    var deferred = P.defer();\n    var stdout = '', stderr = '';\n    child.stdout.on('data', function(data){\n        stdout += data;\n    });\n    child.stderr.on('data', function(data){\n        stderr += data;\n    });\n    child.on('exit', function(code, signal){\n        if(successCodes.indexOf(code) !== -1){\n            deferred.resolve(stdout);\n        }\n        else{\n            deferred.reject(new Error(util.format('remoteExec return code %s on %s@%s - %s\\n%s', code, user, ip, cmd, stderr)));\n        }\n    });\n    return deferred.promise;\n};\n\nexports.waitUntil = function(fn, checkInterval){\n    if(!checkInterval){\n        checkInterval = 100;\n    }\n\n    var deferred = P.defer();\n    var check = function(){\n        if(fn()){\n            deferred.resolve();\n        }\n        else{\n            setTimeout(check, checkInterval);\n        }\n    };\n    check();\n\n    return deferred.promise;\n};\n\nexports.rateCounter = function(opts){\n    opts = opts || {};\n    var perserveSeconds = opts.perserveSeconds || 3600;\n    var sampleSeconds = opts.sampleSeconds || 5;\n\n    var counts = {};\n    var cleanInterval = null;\n\n    var getCurrentSlot = function(){\n        return Math.floor(Date.now() / 1000 / sampleSeconds);\n    };\n\n    var beginSlot = getCurrentSlot();\n\n    var counter = {\n        inc : function(){\n            var slotNow = getCurrentSlot();\n            if(!counts.hasOwnProperty(slotNow)){\n                counts[slotNow] = 0;\n            }\n            counts[slotNow]++;\n        },\n\n        reset : function(){\n            counts = {};\n            beginSlot = getCurrentSlot();\n        },\n\n        clean : function(){\n            var slotNow = getCurrentSlot();\n            Object.keys(counts).forEach(function(slot){\n                if(slot < slotNow - Math.floor(perserveSeconds / sampleSeconds)){\n                    delete counts[slot];\n                }\n            });\n        },\n\n        rate : function(lastSeconds){\n            var slotNow = getCurrentSlot();\n            var total = 0;\n            var startSlot = slotNow - Math.floor(lastSeconds / sampleSeconds);\n            if(startSlot < beginSlot){\n                startSlot = beginSlot;\n            }\n            for(var slot = startSlot; slot < slotNow; slot++){\n                total += counts[slot] || 0;\n            }\n            return total / ((slotNow - startSlot) * sampleSeconds);\n        },\n\n        stop : function(){\n            clearInterval(cleanInterval);\n        },\n\n        counts : function(){\n            return counts;\n        }\n    };\n\n    cleanInterval = setInterval(function(){\n        counter.clean();\n    }, sampleSeconds * 1000);\n\n    return counter;\n};\n\nexports.hrtimer = function(autoStart){\n    var total = 0;\n    var starttime = null;\n\n    var timer = {\n        start : function(){\n            if(starttime){\n                return;\n            }\n            starttime = process.hrtime();\n        },\n        stop : function(){\n            if(!starttime){\n                return;\n            }\n            var timedelta = process.hrtime(starttime);\n            total += timedelta[0] * 1000 + timedelta[1] / 1000000;\n            return total;\n        },\n        total : function(){\n            return total; //in ms\n        },\n    };\n\n    if(autoStart){\n        timer.start();\n    }\n    return timer;\n};\n\nexports.timeCounter = function(){\n    var counts = {};\n\n    return {\n        add : function(name, time){\n            if(!counts.hasOwnProperty(name)){\n                counts[name] = [0, 0, 0]; // total, count, average\n            }\n            var count = counts[name];\n            count[0] += time;\n            count[1]++;\n            count[2] = count[0] / count[1];\n        },\n        reset : function(){\n            counts = {};\n        },\n        getCounts : function(){\n            return counts;\n        },\n    };\n};\n\n\n// trick v8 to not use hidden class\n// https://github.com/joyent/node/issues/25661\nexports.forceHashMap = function(){\n    var obj = {k : 1};\n    delete obj.k;\n    return obj;\n};\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/config.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar P = require('bluebird');\nvar path = require('path');\nvar fs = require('fs-extra');\nvar mkdirp = require('mkdirp');\nvar memdbLogger = require('memdb-logger');\nvar logger = memdbLogger.getLogger('memdb', __filename);\nvar utils = require('./utils');\n\nvar _config = null;\n\nexports.init = function(confPath, shardId){\n    var searchPaths = [];\n    var homePath = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;\n\n    var localDataPath = path.join(homePath, '.memdb');\n    mkdirp(localDataPath);\n\n    searchPaths = confPath ? [confPath] : [path.join(homePath, '.memdb/memdb.conf.js'), '/etc/memdb.conf.js'];\n\n    var conf = null;\n    for(var i=0; i<searchPaths.length; i++){\n        if(fs.existsSync(searchPaths[i])){\n            confPath = path.resolve(searchPaths[i]);\n            conf = require(confPath);\n            exports.path = confPath;\n            break;\n        }\n    }\n    if(!conf){\n        if(confPath){\n            throw new Error('config file not found - ' + searchPaths);\n        }\n\n        // copy and load default config\n        var confTemplatePath = path.join(__dirname, '../memdb.conf.js');\n        var defaultConfPath = path.join(localDataPath, 'memdb.conf.js');\n        fs.copySync(confTemplatePath, defaultConfPath);\n\n        conf = require(defaultConfPath);\n    }\n\n    // Configure promise\n    if(conf.promise && conf.promise.longStackTraces){\n        P.longStackTraces();\n    }\n\n    // Configure log\n    var logConf = conf.log || {};\n\n    var logPath = logConf.path || path.join(localDataPath, 'log');\n    mkdirp(logPath);\n\n    console.log('log path: %s', logPath);\n    memdbLogger.configure(path.join(__dirname, 'log4js.json'), {shardId : shardId || '$', base : logPath});\n\n    var level = logConf.level || 'INFO';\n    memdbLogger.setGlobalLogLevel(memdbLogger.levels[level]);\n\n    // heapdump\n    if(conf.heapdump){\n        require('heapdump');\n    }\n\n    _config = conf;\n};\n\nexports.getShardIds = function(){\n    if(!_config){\n        throw new Error('please config.init first');\n    }\n    return Object.keys(_config.shards);\n};\n\nexports.shardConfig = function(shardId){\n    if(!_config){\n        throw new Error('please config.init first');\n    }\n\n    var conf = utils.clone(_config);\n\n    var shardConf = conf.shards && conf.shards[shardId];\n    if(!shardConf){\n        throw new Error('shard ' + shardId + ' not configured');\n    }\n    // Override shard specific config\n    for(var key in shardConf){\n        conf[key] = shardConf[key];\n    }\n\n    conf.shardId = shardId;\n    return conf;\n};\n\nexports.clusterConfig = function(){\n    return _config;\n};\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/connection.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar P = require('bluebird');\nvar Logger = require('memdb-logger');\nvar consts = require('./consts');\nvar Collection = require('./collection');\nvar util = require('util');\nvar utils = require('./utils');\n\nvar Connection = function(opts){\n    opts = opts || {};\n\n    this._id = opts._id;\n    this.shard = opts.shard;\n\n    this.config = opts.config || {};\n    this.collections = {};\n\n    this.lockedKeys = utils.forceHashMap();\n\n    this.logger = Logger.getLogger('memdb', __filename, 'shard:' + this.shard._id);\n};\n\nvar proto = Connection.prototype;\n\nproto.close = function(){\n    if(this.isDirty()){\n        this.rollback();\n    }\n    for(var name in this.collections){\n        this.collections[name].close();\n    }\n};\n\nconsts.collMethods.forEach(function(method){\n    proto[method] = function(name){\n        var collection = this.getCollection(name);\n        // remove 'name' arg\n        var args = [].slice.call(arguments, 1);\n\n        this.logger.debug('[conn:%s] %s.%s(%j)', this._id, name, method, args);\n        return collection[method].apply(collection, args);\n    };\n});\n\nproto.commit = function(){\n    var self = this;\n    return P.each(Object.keys(this.collections), function(name){\n        var collection = self.collections[name];\n        return collection.commitIndex();\n    })\n    .then(function(){\n        return self.shard.commit(self._id, Object.keys(self.lockedKeys));\n    })\n    .then(function(){\n        self.lockedKeys = {};\n\n        self.logger.debug('[conn:%s] commited', self._id);\n        return true;\n    });\n};\n\n// sync method\nproto.rollback = function(){\n    var self = this;\n    Object.keys(this.collections).forEach(function(name){\n        self.collections[name].rollbackIndex();\n    });\n\n    this.shard.rollback(this._id, Object.keys(this.lockedKeys));\n    this.lockedKeys = {};\n\n    this.logger.debug('[conn:%s] rolledback', this._id);\n    return true;\n};\n\nproto.flushBackend = function(){\n    return this.shard.flushBackend(this._id);\n};\n\n// for internal use\nproto.$unload = function(key){\n    return this.shard.$unload(key);\n};\n// for internal use\nproto.$findReadOnly = function(key, fields){\n    return this.shard.find(null, key, fields);\n};\n\nproto.getCollection = function(name, isIndex){\n    if(!isIndex && name && name.indexOf('index.') === 0){\n        throw new Error('Collection name can not begin with \"index.\"');\n    }\n\n    var self = this;\n    if(!this.collections[name]){\n        var collection = new Collection({\n            name : name,\n            shard : this.shard,\n            conn : this,\n            config : this.config.collections[name] || {},\n        });\n\n        collection.on('lock', function(id){\n            var key = name + '$' + id;\n            self.lockedKeys[key] = true;\n        });\n\n        this.collections[name] = collection;\n    }\n    return this.collections[name];\n};\n\n\nproto.isDirty = function(){\n    return Object.keys(this.lockedKeys).length > 0;\n};\n\nmodule.exports = Connection;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/consts.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar exports = {};\n\nexports.collMethods = ['find', 'findOne', 'findById',\n                    'findReadOnly', 'findOneReadOnly', 'findByIdReadOnly',\n                    'insert', 'update', 'remove', 'lock', 'count'];\n\nexports.connMethods = ['commit', 'rollback', 'eval', 'info', 'resetCounter', 'flushBackend', '$unload', '$findReadOnly'];\n\nexports.version = require('../package').version;\nexports.minClientVersion = '0.4';\n\nmodule.exports = exports;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/database.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar P = require('bluebird');\nvar Logger = require('memdb-logger');\nvar utils = require('./utils');\nvar util = require('util');\nvar os = require('os');\nvar EventEmitter = require('events').EventEmitter;\nvar Connection = require('./connection');\nvar Shard = require('./shard');\nvar consts = require('./consts');\nvar vm = require('vm');\nvar AsyncLock = require('async-lock');\nvar _ = require('lodash');\n\nvar DEFAULT_SLOWQUERY = 2000;\n\n// Extend promise\nutils.extendPromise(P);\n\nvar Database = function(opts){\n    // clone since we want to modify it\n    opts = utils.clone(opts) || {};\n\n    this.logger = Logger.getLogger('memdb', __filename, 'shard:' + opts.shardId);\n\n    this.connections = utils.forceHashMap();\n    this.connectionLock = new AsyncLock({Promise : P});\n\n    this.dbWrappers = utils.forceHashMap(); //{connId : dbWrapper}\n\n    this.opsCounter = utils.rateCounter();\n    this.tpsCounter = utils.rateCounter();\n\n    opts.slowQuery = opts.slowQuery || DEFAULT_SLOWQUERY;\n\n    // Parse index config\n    opts.collections = opts.collections || {};\n\n    Object.keys(opts.collections).forEach(function(name){\n        var collection = opts.collections[name];\n        var indexes = {};\n        (collection.indexes || []).forEach(function(index){\n            if(!Array.isArray(index.keys)){\n                index.keys = [index.keys];\n            }\n            var indexKey = JSON.stringify(index.keys.sort());\n            if(indexes[indexKey]){\n                throw new Error('Duplicate index keys - ' + indexKey);\n            }\n\n            delete index.keys;\n            indexes[indexKey] = index;\n        });\n        collection.indexes = indexes;\n    });\n\n    this.logger.info('parsed opts: %j', opts);\n\n    this.shard = new Shard(opts);\n\n    this.config = opts;\n\n    this.timeCounter = utils.timeCounter();\n};\n\nutil.inherits(Database, EventEmitter);\n\nvar proto = Database.prototype;\n\nproto.start = function(){\n    var self = this;\n    return this.shard.start()\n    .then(function(){\n        self.logger.info('database started');\n    });\n};\n\nproto.stop = function(force){\n    var self = this;\n\n    this.opsCounter.stop();\n    this.tpsCounter.stop();\n\n    return P.try(function(){\n        // Make sure no new request come anymore\n\n        // Wait for all operations finish\n        return utils.waitUntil(function(){\n            return !self.connectionLock.isBusy();\n        });\n    })\n    .then(function(){\n        self.logger.debug('all requests finished');\n        return self.shard.stop(force);\n    })\n    .then(function(){\n        self.logger.info('database stoped');\n    });\n};\n\nproto.connect = function(){\n    var connId = utils.uuid();\n    var opts = {\n        _id : connId,\n        shard : this.shard,\n        config : this.config,\n        logger : this.logger\n    };\n    var conn = new Connection(opts);\n    this.connections[connId] = conn;\n\n    var self = this;\n    var dbWrapper = {};\n    consts.collMethods.concat(consts.connMethods).forEach(function(method){\n        dbWrapper[method] = function(){\n            return self.execute(connId, method, [].slice.call(arguments));\n        };\n    });\n    this.dbWrappers[connId] = dbWrapper;\n\n    this.logger.info('[conn:%s] connection created', connId);\n    return {\n        connId : connId,\n    };\n};\n\nproto.disconnect = function(connId){\n    var self = this;\n    return P.try(function(){\n        var conn = self.getConnection(connId);\n        return self.execute(connId, 'close', [], {ignoreConcurrent : true});\n    })\n    .then(function(){\n        delete self.connections[connId];\n        delete self.dbWrappers[connId];\n        self.logger.info('[conn:%s] connection closed', connId);\n    });\n};\n\n// Execute a command\nproto.execute = function(connId, method, args, opts){\n    opts = opts || {};\n    var self = this;\n\n    if(method[0] === '$'){ // Internal method (allow concurrent call)\n        var conn = this.getConnection(connId);\n        return conn[method].apply(conn, args);\n    }\n\n    if(method === 'info'){\n        return {\n            connId : connId,\n            ver : consts.version,\n            uptime : process.uptime(),\n            mem : process.memoryUsage(),\n            // rate for last 1, 5, 15 minutes\n            ops : [this.opsCounter.rate(60), this.opsCounter.rate(300), this.opsCounter.rate(900)],\n            tps : [this.tpsCounter.rate(60), this.tpsCounter.rate(300), this.tpsCounter.rate(900)],\n            lps : [this.shard.loadCounter.rate(60), this.shard.loadCounter.rate(300), this.shard.loadCounter.rate(900)],\n            ups : [this.shard.unloadCounter.rate(60), this.shard.unloadCounter.rate(300), this.shard.unloadCounter.rate(900)],\n            pps : [this.shard.persistentCounter.rate(60), this.shard.persistentCounter.rate(300), this.shard.persistentCounter.rate(900)],\n            counter : this.timeCounter.getCounts(),\n        };\n    }\n    else if(method === 'resetCounter'){\n        this.opsCounter.reset();\n        this.tpsCounter.reset();\n        this.shard.loadCounter.reset();\n        this.shard.unloadCounter.reset();\n        this.shard.persistentCounter.reset();\n\n        this.timeCounter.reset();\n        return;\n    }\n    else if(method === 'eval'){\n        var script = args[0] || '';\n        var sandbox = args[1] || {};\n        sandbox.require = require;\n        sandbox.P = P;\n        sandbox._ = _;\n        sandbox.db = this.dbWrappers[connId];\n\n        var context = vm.createContext(sandbox);\n\n        return vm.runInContext(script, context);\n    }\n\n    // Query in the same connection must execute in series\n    // This is usually a client bug here\n    if(this.connectionLock.isBusy(connId) && !opts.ignoreConcurrent){\n        var err = new Error(util.format('[conn:%s] concurrent query on same connection. %s(%j)', connId, method, args));\n        this.logger.error(err);\n        throw err;\n    }\n\n    // Ensure series execution in same connection\n    return this.connectionLock.acquire(connId, function(cb){\n        self.logger.debug('[conn:%s] start %s(%j)...', connId, method, args);\n        if(method === 'commit' || method === 'rollback'){\n            self.tpsCounter.inc();\n        }\n        else{\n            self.opsCounter.inc();\n        }\n\n        var hrtimer = utils.hrtimer(true);\n        var conn = null;\n\n        return P.try(function(){\n            conn = self.getConnection(connId);\n\n            var func = conn[method];\n            if(typeof(func) !== 'function'){\n                throw new Error('unsupported command - ' + method);\n            }\n            return func.apply(conn, args);\n        })\n        .then(function(ret){\n            var timespan = hrtimer.stop();\n            var level = timespan < self.config.slowQuery ? 'info' : 'warn'; // warn slow query\n            self.logger[level]('[conn:%s] %s(%j) => %j (%sms)', connId, method, args, ret, timespan);\n\n            var category = method;\n            if(consts.collMethods.indexOf(method) !== -1){\n                category += ':' + args[0];\n            }\n            self.timeCounter.add(category, timespan);\n\n            return ret;\n        }, function(err){\n            var timespan = hrtimer.stop();\n            self.logger.error('[conn:%s] %s(%j) => %s (%sms)', connId, method, args, err.stack ? err.stack : err, timespan);\n\n            if(conn){\n                conn.rollback();\n            }\n\n            // Rethrow to client\n            throw err;\n        })\n        .nodeify(cb);\n    });\n};\n\nproto.getConnection = function(id){\n    var conn = this.connections[id];\n    if(!conn){\n        throw new Error('connection ' + id + ' not exist');\n    }\n    return conn;\n};\n\nmodule.exports = Database;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/shard.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar _ = require('lodash');\nvar P = require('bluebird');\nvar Logger = require('memdb-logger');\nvar util = require('util');\nvar redis = require('redis');\nvar AsyncLock = require('async-lock');\nvar EventEmitter = require('events').EventEmitter;\nvar backends = require('./backends');\nvar Document = require('./document'); //jshint ignore:line\nvar BackendLocker = require('./backendlocker');\nvar Slave = require('./slave');\nvar utils = require('./utils');\nvar AutoConnection = require('../lib/autoconnection');\n\nvar STATE = {\n    INITED : 0,\n    STARTING : 1,\n    RUNNING : 2,\n    STOPING : 3,\n    STOPED : 4\n};\n\n// memory limit 1024MB\nvar DEFAULT_MEMORY_LIMIT = 1024;\n\n// GC check interval\nvar DEFAULT_GC_INTERVAL = 1000;\n\n// unload doc count per GC cycle\nvar DEFAULT_GC_COUNT = 100;\n\n// Idle time before doc is unloaded\n// tune this to balance memory usage and performance\n// set 0 to never\nvar DEFAULT_IDLE_TIMEOUT = 1800 * 1000;\n\n// Persistent delay after doc has commited (in ms)\n// tune this to balance backend data delay and performance\n// set 0 to never\nvar DEFAULT_PERSISTENT_DELAY = 600 * 1000;\n\n// timeout for locking backend doc\nvar DEFAULT_BACKEND_LOCK_TIMEOUT = 30 * 1000;\n// retry interval for backend lock\nvar DEFAULT_BACKEND_LOCK_RETRY_INTERVAL = 50;\n\n// delay between unload and load\n// Can't load again immediately, prevent 'locking hungry' from other shards\nvar DEFAULT_RELOAD_DELAY = 20;\n\n// timeout for locking doc\nvar DEFAULT_LOCK_TIMEOUT = 30 * 1000;\n\n// heartbeat settings, must be multiple of 1000\nvar DEFAULT_HEARTBEAT_INTERVAL = 2 * 1000;\nvar DEFAULT_HEARTBEAT_TIMEOUT = 5 * 1000;\n\n\nvar Shard = function(opts){\n    EventEmitter.call(this);\n\n    opts = opts || {};\n\n    this._id = opts.shardId;\n    if(!this._id){\n        throw new Error('shardId is empty');\n    }\n    this._id = this._id.toString();\n    if(this._id.indexOf('$') !== -1){\n        throw new Error('shardId can not contain \"$\"');\n    }\n\n    this.logger = Logger.getLogger('memdb', __filename, 'shard:' + this._id);\n\n    this.config = {\n        locking : opts.locking || {},\n        backend : opts.backend || {},\n        slave : opts.slave || {},\n\n        shards : opts.shards || {},\n\n        idleTimeout : opts.hasOwnProperty('idleTimeout') ? opts.idleTimeout : DEFAULT_IDLE_TIMEOUT,\n        persistentDelay : opts.hasOwnProperty('persistentDelay') ?  opts.persistentDelay : DEFAULT_PERSISTENT_DELAY,\n\n        heartbeatInterval : opts.heartbeatInterval || DEFAULT_HEARTBEAT_INTERVAL,\n        heartbeatTimeout : opts.heartbeatTimeout || DEFAULT_HEARTBEAT_TIMEOUT,\n        backendLockTimeout : opts.backendLockTimeout || DEFAULT_BACKEND_LOCK_TIMEOUT,\n        backendLockRetryInterval : opts.backendLockRetryInterval || DEFAULT_BACKEND_LOCK_RETRY_INTERVAL,\n        reloadDelay : opts.reloadDelay || DEFAULT_RELOAD_DELAY,\n        lockTimeout : opts.lockTimeout || DEFAULT_LOCK_TIMEOUT,\n\n        memoryLimit : opts.memoryLimit || DEFAULT_MEMORY_LIMIT,\n        gcCount : opts.gcCount || DEFAULT_GC_COUNT,\n        gcInterval : opts.gcInterval || DEFAULT_GC_INTERVAL,\n\n        disableSlave : opts.disableSlave || false,\n\n        collections : opts.collections || {},\n    };\n\n    // global locking\n    var lockerConf = this.config.locking;\n    lockerConf.shardId = this._id;\n    lockerConf.heartbeatTimeout = this.config.heartbeatTimeout;\n    lockerConf.heartbeatInterval = this.config.heartbeatInterval;\n    this.backendLocker = new BackendLocker(lockerConf);\n\n    // backend storage\n    var backendConf = this.config.backend;\n    backendConf.shardId = this._id;\n    this.backend = backends.create(backendConf);\n\n    // slave redis\n    var slaveConf = this.config.slave;\n    slaveConf.shardId = this._id;\n    this.slave = new Slave(slaveConf);\n\n    // memdb client to communicate with other shards\n    this.autoconn = new AutoConnection({\n        shards : this.config.shards,\n        concurrentInConnection : true,\n    });\n\n    // Document storage {key : doc}\n    this.docs = utils.forceHashMap();\n\n    // Newly commited docs (for incremental _save)\n    this.commitedKeys = utils.forceHashMap(); // {key : version}\n\n    // Idle timeout before unload\n    this.idleTimeouts = utils.forceHashMap(); // {key : timeout}\n\n    // Doc persistent timeout\n    this.persistentTimeouts = utils.forceHashMap(); // {key : timeout}\n\n    // GC interval\n    this.gcInterval = null;\n\n    // Lock async operations for each key\n    this.keyLock = new AsyncLock({Promise : P});\n\n    // Task locker\n    this.taskLock = new AsyncLock({Promise : P});\n\n    // Doc locker\n    this.docLock = new AsyncLock({\n        timeout : this.config.lockTimeout,\n        Promise : P,\n    });\n\n    // Current concurrent commiting processes\n    this.commitingCount = 0;\n\n    // Current key unloading task\n    this.unloadingKeys = utils.forceHashMap();\n\n    this.loadCounter = utils.rateCounter();\n    this.unloadCounter = utils.rateCounter();\n    this.persistentCounter = utils.rateCounter();\n\n    this.state = STATE.INITED;\n};\n\nutil.inherits(Shard, EventEmitter);\n\nvar proto = Shard.prototype;\n\nproto.start = function(){\n    this._ensureState(STATE.INITED);\n    this.state = STATE.STARTING;\n\n    return P.bind(this)\n    .then(function(){\n        return this.backendLocker.start();\n    })\n    .then(function(){\n        return this.backend.start();\n    })\n    .then(function(){\n        if(!this.config.disableSlave){\n            return this.slave.start();\n        }\n    })\n    .then(function(){\n        if(!this.config.disableSlave){\n            return this.restoreFromSlave();\n        }\n    })\n    .then(function(){\n        this.gcInterval = setInterval(this.gc.bind(this), this.config.gcInterval);\n\n        this.state = STATE.RUNNING;\n        this.emit('start');\n        this.logger.info('shard started');\n    });\n};\n\nproto.stop = function(){\n    this._ensureState(STATE.RUNNING);\n\n    // This will prevent any further requests\n    // All commited data will be saved, while uncommited data will be rolled back\n    this.state = STATE.STOPING;\n\n    clearInterval(this.gcInterval);\n\n    return P.bind(this)\n    .then(function(){\n        // Wait for all running task finish\n        return this.taskLock.acquire('', function(){});\n    })\n    .then(function(){\n        this.logger.debug('all running tasks finished');\n\n        // Wait for all commit process finish\n        var deferred = P.defer();\n        var self = this;\n        var check = function(){\n            if(self.commitingCount <= 0){\n                deferred.resolve();\n            }\n            else{\n                setTimeout(check, 200);\n            }\n        };\n        check();\n        return deferred.promise;\n    })\n    .then(function(){\n        this.logger.debug('all commit processes finished');\n        // WARN: Make sure all connections are closed now\n\n        var self = this;\n        return P.mapLimit(Object.keys(this.docs), function(key){\n            return self.keyLock.acquire(key, function(){\n                return self._unload(key);\n            })\n            .catch(function(e){\n                self.logger.error(e.stack);\n            });\n        });\n    })\n    .then(function(){\n        this.logger.debug('all docs unloaded');\n\n        this.loadCounter.stop();\n        this.unloadCounter.stop();\n        this.persistentCounter.stop();\n\n        if(!this.config.disableSlave){\n            return this.slave.stop();\n        }\n    })\n    .then(function(){\n        return this.backend.stop();\n    })\n    .then(function(){\n        return this.backendLocker.stop();\n    })\n    .then(function(){\n        return this.autoconn.close();\n    })\n    .then(function(){\n        this.state = STATE.STOPED;\n        this.emit('stop');\n        this.logger.info('shard stoped');\n    });\n};\n\nproto.find = function(connId, key, fields){\n    this._ensureState(STATE.RUNNING);\n    var self = this;\n\n    if(this.docs[key]){ //already loaded\n        if(this.docs[key].isFree()){\n            // restart idle timer if doc doesn't locked by anyone\n            this._cancelIdleTimeout(key);\n            this._startIdleTimeout(key);\n        }\n\n        var ret = this.docs[key].find(connId, fields);\n        self.logger.debug('[conn:%s] find(%s, %j) => %j', connId, key, fields, ret);\n        return ret;\n    }\n\n    return this.keyLock.acquire(key, function(){\n        return P.try(function(){\n            return self._load(key);\n        })\n        .then(function(){\n            return self.docs[key].find(connId, fields);\n        })\n        .then(function(ret){\n            self.logger.debug('[conn:%s] find(%s, %j) => %j', connId, key, fields, ret);\n            return ret;\n        });\n    });\n};\n\nproto.update = function(connId, key, doc, opts){\n    this._ensureState(STATE.RUNNING);\n\n    // Since lock is called before, so doc is loaded for sure\n    var ret = this._doc(key).update(connId, doc, opts);\n\n    this.logger.debug('[conn:%s] update(%s, %j, %j) => %s', connId, key, doc, opts, ret);\n    return ret;\n};\n\nproto.insert = function(connId, key, doc){\n    this._ensureState(STATE.RUNNING);\n\n    var ret = this._doc(key).insert(connId, doc);\n    this.logger.debug('[conn:%s] insert(%s, %j) => %s', connId, key, doc, ret);\n    return ret;\n};\n\nproto.remove = function(connId, key){\n    this._ensureState(STATE.RUNNING);\n\n    var ret = this._doc(key).remove(connId);\n    this.logger.debug('[conn:%s] remove(%s) => %s', connId, key, ret);\n    return ret;\n};\n\nproto.rollback = function(connId, keys){\n    // Skip state check\n\n    if(!Array.isArray(keys)){\n        keys = [keys];\n    }\n\n    var self = this;\n    keys.forEach(function(key){\n        self._doc(key).rollback(connId);\n    });\n\n    this.logger.debug('[conn:%s] rollback(%j)', connId, keys);\n};\n\nproto.lock = function(connId, key){\n    this._ensureState(STATE.RUNNING);\n\n    if(this.isLocked(connId, key)){\n        return true;\n    }\n\n    this.logger.debug('[conn:%s] shard.lock(%s) start', connId, key);\n\n    var self = this;\n    return this.keyLock.acquire(key, function(){\n        return P.try(function(){\n            return self._load(key);\n        })\n        .then(function(){\n            return self.docs[key].lock(connId)\n            .then(function(){\n                self.logger.debug('[conn:%s] shard.lock(%s) success', connId, key);\n                return true;\n            }, function(e){\n                throw new Error(util.format('[conn:%s] shard.lock(%s) failed', connId, key));\n            });\n        });\n    });\n};\n\nproto.commit = function(connId, keys){\n    this._ensureState(STATE.RUNNING);\n\n    if(!Array.isArray(keys)){\n        keys = [keys];\n    }\n    if(keys.length === 0){\n        return;\n    }\n\n    var self = this;\n\n    keys.forEach(function(key){\n        if(!self.isLocked(connId, key)){\n            throw new Error('[conn:%s] %s not locked', connId, key);\n        }\n    });\n\n    this.commitingCount++;\n\n    // commit is not concurrency safe for same connection.\n    // but database.js guarantee that every request from same connection are in series.\n    return P.try(function(){\n        if(self.config.disableSlave){\n            return;\n        }\n\n        // Sync data to slave\n        if(keys.length === 1){\n            var key = keys[0];\n            var doc = self._doc(key)._getChanged();\n            return self.slave.set(key, doc);\n        }\n        else{\n            var docs = utils.forceHashMap();\n            keys.forEach(function(key){\n                docs[key] = self._doc(key)._getChanged();\n            });\n            return self.slave.setMulti(docs);\n        }\n        //TODO: possibly loss consistency\n        //      if setMulti return failed but actually sccuess\n    })\n    .then(function(){\n        // Real Commit\n        keys.forEach(function(key){\n            self._doc(key).commit(connId);\n        });\n\n        self.logger.debug('[conn:%s] commit(%j)', connId, keys);\n    })\n    .finally(function(ret){\n        self.commitingCount--;\n    });\n};\n\nproto.isLocked = function(connId, key){\n    return this.docs[key] && this.docs[key].isLocked(connId);\n};\n\nproto.findReadOnly = function(connId, key, fields){\n    this._ensureState(STATE.RUNNING);\n    var self = this;\n\n    if(this._isLoaded(key)){\n        return this.find(connId, key, fields);\n    }\n    return P.try(function(){\n        return self.backendLocker.getHolderId(key);\n    })\n    .then(function(shardId){\n        if(!shardId || shardId === self._id){\n            return self.find(connId, key, fields);\n        }\n        return self.autoconn.$findReadOnly(shardId, key, fields);\n    });\n};\n\n// Called by other shards\nproto.$unload = function(key){\n    if(this.state !== STATE.RUNNING){\n        return false;\n    }\n    if(this.unloadingKeys[key]){\n        return false;\n    }\n\n    this.unloadingKeys[key] = true;\n\n    var self = this;\n    var deferred = P.defer();\n\n    this.keyLock.acquire(key, function(){\n        if(!self.docs[key]){\n            // possibly timing issue\n            // or a redundant backend lock is held caused by unsuccessful unload\n            self.logger.warn('this shard does not hold %s', key);\n\n            return P.try(function(){\n                return self.slave.del(key);\n            })\n            .then(function(){\n                return self._unlockBackend(key);\n            })\n            .then(function(){\n                deferred.resolve(true);\n            }, function(e){\n                deferred.reject(e);\n                throw e;\n            });\n        }\n\n        return P.try(function(){\n            return self._unload(key);\n        })\n        .then(function(){\n            deferred.resolve(true);\n        }, function(e){\n            deferred.reject(e);\n            throw e;\n        })\n        .delay(self.config.reloadDelay);\n    })\n    .catch(function(e){\n        self.logger.error(e.stack);\n    })\n    .finally(function(){\n        delete self.unloadingKeys[key];\n    });\n\n    return deferred.promise;\n};\n\n// internal method, not concurrency safe\nproto._load = function(key){\n    if(this.docs[key]){ // already loaded\n        return;\n    }\n\n    this.logger.debug('start load %s', key);\n\n    var obj = null;\n\n    var self = this;\n    return P.try(function(){\n        // get backend lock\n        return self._lockBackend(key);\n    })\n    .then(function(){\n        var res = self._resolveKey(key);\n\n        return self.backend.get(res.name, res.id);\n    })\n    .then(function(ret){\n        obj = ret;\n        if(!self.config.disableSlave){\n            // Sync data to slave\n            return self.slave.set(key, obj);\n        }\n    })\n    .then(function(){\n        self._addDoc(key, obj);\n\n        self.loadCounter.inc();\n        self.logger.info('loaded %s', key);\n    });\n};\n\nproto._addDoc = function(key, obj){\n    var self = this;\n\n    var res = this._resolveKey(key);\n    var coll = this.config.collections[res.name];\n    var indexes = (coll && coll.indexes) || {};\n\n    var opts = {\n        _id : res.id,\n        doc: obj,\n        indexes: indexes,\n        locker : this.docLock,\n        lockKey : key,\n    };\n    var doc = new Document(opts);\n\n    this._startIdleTimeout(key);\n\n    doc.on('lock', function(){\n        self._cancelIdleTimeout(key);\n    });\n\n    doc.on('unlock', function(){\n        self._startIdleTimeout(key);\n    });\n\n    doc.on('commit', function(){\n        self._setCommited(key);\n\n        // delay sometime and persistent to backend\n        if(!self.persistentTimeouts.hasOwnProperty(key) && self.config.persistentDelay >= 0){\n            self.persistentTimeouts[key] = setTimeout(function(){\n                delete self.persistentTimeouts[key];\n                return self.keyLock.acquire(key, function(){\n                    return self._persistent(key);\n                })\n                .catch(function(err){\n                    self.logger.error(err.stack);\n                });\n            }, self.config.persistentDelay);\n        }\n    });\n\n    doc.on('updateIndex', function(connId, indexKey, oldValue, newValue){\n        // pass event to collection\n        self.emit('updateIndex$' + res.name + '$' + connId, res.id, indexKey, oldValue, newValue);\n    });\n\n    // Loaded at this instant\n    self.docs[key] = doc;\n};\n\n// internal method, not concurrency safe\nproto._unload = function(key){\n    if(!this.docs[key]){ //already unloaded\n        return;\n    }\n\n    this.logger.debug('start unload %s', key);\n\n    var doc = this.docs[key];\n\n    return P.bind(this)\n    .then(function(){\n        // Wait all existing lock release\n        return doc._waitUnlock();\n    })\n    .then(function(){\n        // Persistent immediately\n        return this._persistent(key);\n    })\n    .then(function(){\n        if(!this.config.disableSlave){\n            // sync data to slave\n            return this.slave.del(key);\n        }\n    })\n    .then(function(){\n        this._cancelIdleTimeout(key);\n\n        if(this.persistentTimeouts.hasOwnProperty(key)){\n            clearTimeout(this.persistentTimeouts[key]);\n            delete this.persistentTimeouts[key];\n        }\n\n        doc.removeAllListeners('commit');\n        doc.removeAllListeners('updateIndex');\n        doc.removeAllListeners('lock');\n        doc.removeAllListeners('unlock');\n\n        // _unloaded at this instant\n        delete this.docs[key];\n\n        // Release backend lock\n        return this._unlockBackend(key);\n    })\n    .then(function(){\n        this.unloadCounter.inc();\n\n        this.logger.info('unloaded %s', key);\n    });\n};\n\n// internal method, not concurrency safe\nproto._lockBackend = function(key){\n    var self = this;\n    return P.try(function(){\n        return self.backendLocker.tryLock(key);\n    })\n    .then(function(success){\n        if(success){\n            return;\n        }\n\n        var startTick = Date.now();\n\n        var tryLock = function(wait){\n            return P.try(function(){\n                return self.backendLocker.getHolderId(key);\n            })\n            .then(function(shardId){\n                if(shardId === self._id){\n                    // already locked\n                    return;\n                }\n\n                return P.try(function(){\n                    if(shardId){\n                        // notify holder to unload the doc\n                        return self.autoconn.$unload(shardId, key);\n                    }\n                    else{\n                        return true;\n                    }\n                })\n                .then(function(success){\n                    if(success){\n                        return self.backendLocker.tryLock(key);\n                    }\n                    else{\n                        return false;\n                    }\n                })\n                .then(function(success){\n                    if(success){\n                        self.logger.debug('locked backend doc - %s (%sms)', key, Date.now() - startTick);\n                        return;\n                    }\n\n                    if(Date.now() - startTick >= self.config.backendLockTimeout){\n                        throw new Error('lock backend doc - ' + key + ' timed out');\n                    }\n\n                    // delay some time and try again\n                    return P.delay(wait / 2 + _.random(wait))\n                    .then(function(){\n                        return tryLock(wait);\n                    });\n                });\n            });\n        };\n\n        return tryLock(self.config.backendLockRetryInterval);\n    });\n};\n\nproto._unlockBackend = function(key){\n    return this.backendLocker.unlock(key);\n};\n\n// internal method, not concurrency safe\nproto._persistent = function(key){\n    if(!this.commitedKeys.hasOwnProperty(key)){\n        return; // no change\n    }\n\n    var doc = this._doc(key)._getCommited();\n    var ver = this.commitedKeys[key]; // get current version\n\n    var self = this;\n    var res = this._resolveKey(key);\n\n    return this.backend.set(res.name, res.id, doc)\n    .then(function(){\n        // no new change, remove the flag\n        if(self.commitedKeys[key] === ver){\n            delete self.commitedKeys[key];\n        }\n\n        self.persistentCounter.inc();\n        self.logger.debug('persistented %s', key);\n    });\n};\n\n//TODO: setTimeout is slow, takes 1/100000 sec\nproto._startIdleTimeout = function(key){\n    if(!this.config.idleTimeout){\n        return;\n    }\n\n    var self = this;\n    this.idleTimeouts[key] = setTimeout(function(){\n        return self.keyLock.acquire(key, function(){\n            if(self.docs[key]){\n                self.logger.debug('%s idle timed out, will unload', key);\n                return self._unload(key);\n            }\n        })\n        .catch(function(e){\n            self.logger.error(e.stack);\n        });\n    }, this.config.idleTimeout);\n};\n\nproto._cancelIdleTimeout = function(key){\n    clearTimeout(this.idleTimeouts[key]);\n    delete this.idleTimeouts[key];\n};\n\nproto._setCommited = function(key){\n    if(!this.commitedKeys.hasOwnProperty(key)){\n        this.commitedKeys[key] = 0;\n    }\n    this.commitedKeys[key]++;\n};\n\n// Flush changes to backend storage\nproto.flushBackend = function(connId){\n    this._ensureState(STATE.RUNNING);\n    var self = this;\n\n    return this.taskLock.acquire('', function(){\n        return P.mapLimit(Object.keys(self.commitedKeys), function(key){\n            return self.keyLock.acquire(key, function(){\n                return self._persistent(key);\n            });\n        });\n    })\n    .then(function(){\n        self.logger.warn('[conn:%s] flushed Backend', connId);\n        return true;\n    });\n};\n\n// Garbage collection\nproto.gc = function(){\n    if(this.state !== STATE.RUNNING){\n        return;\n    }\n    if(this.taskLock.isBusy('')){\n        return;\n    }\n\n    var self = this;\n    return this.taskLock.acquire('', function(){\n        var usage = process.memoryUsage();\n        var memSize = usage.heapUsed;\n\n        if(memSize < self.config.memoryLimit * 1024 * 1024){\n            // Memory not reach limit, no need to gc\n            return;\n        }\n\n        self.logger.warn('Start GC. Memory usage is too high, please reduce idleTimeout. %j', usage);\n\n        var startTick = Date.now();\n\n        // remove some doc\n        var keys = [], count = 0;\n        for(var key in self.docs){\n            keys.push(key);\n            count++;\n            if(count >= self.config.gcCount){\n                break;\n            }\n        }\n\n        return P.mapLimit(keys, function(key){\n            return self.keyLock.acquire(key, function(){\n                return self._unload(key);\n            })\n            .catch(function(e){\n                self.logger.error(e.stack);\n            });\n        })\n        .then(function(){\n            self.logger.warn('Finish GC in %s ms. %s docs have been unloaded.', Date.now() - startTick, keys.length);\n        })\n        .then(function(){\n            process.nextTick(self.gc.bind(self));\n        });\n    })\n    .catch(function(e){\n        self.logger.error(e.stack);\n    });\n};\n\nproto.restoreFromSlave = function(){\n    this._ensureState(STATE.STARTING);\n\n    return P.bind(this)\n    .then(function(){\n        return this.slave.getAllKeys();\n    })\n    .then(function(keys){\n        if(keys.length === 0){\n            return;\n        }\n\n        this.logger.error('Server not stopped properly, will restore data from slave');\n\n        return P.bind(this)\n        .then(function(){\n            return this.slave.getMulti(keys);\n        })\n        .then(function(items){\n            var self = this;\n            return P.mapLimit(Object.keys(items), function(key){\n                return self.keyLock.acquire(key, function(){\n                    self._addDoc(key, items[key]);\n                    // persistent all docs to backend\n                    self._setCommited(key);\n                    return self._persistent(key);\n                });\n            });\n        })\n        .then(function(){\n            this.logger.warn('restored %s keys from slave', keys.length);\n        });\n    });\n};\n\nproto._doc = function(key){\n    if(!this.docs.hasOwnProperty(key)){\n        throw new Error(key + ' is not loaded');\n    }\n    return this.docs[key];\n};\n\nproto._isLoaded = function(key){\n    return !!this.docs[key];\n};\n\n// key - collectionName$docId\nproto._resolveKey = function(key){\n    var i = key.indexOf('$');\n    if(i === -1){\n        throw new Error('invalid key: ' + key);\n    }\n    return {name : key.slice(0, i), id : key.slice(i + 1)};\n};\n\nproto._ensureState = function(state){\n    if(this.state !== state){\n        throw new Error(util.format('Server state is incorrect, expected %s, actual %s', state, this.state));\n    }\n};\n\nmodule.exports = Shard;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/backends/index.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar MongoBackend = require('./mongo-backend');\nvar RedisBackend = require('./redis-backend');\n\nexports.create = function(config){\n    config = config || {};\n    var engine = config.engine || 'mongodb';\n\n    if(engine === 'mongodb'){\n        return new MongoBackend(config);\n    }\n    else if(engine === 'redis'){\n        return new RedisBackend(config);\n    }\n    else{\n        throw new Error('Invalid backend engine');\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/backends/mongo-backend.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar P = require('bluebird');\nvar Logger = require('memdb-logger');\nvar mongodb = P.promisifyAll(require('mongodb'));\n\nvar MongoBackend = function(opts){\n    opts = opts || {};\n\n    this.config = {\n        url : opts.url || 'mongodb://localhost/test',\n        options : {server : {socketOptions : {autoReconnect : true}, reconnectTries : 10000000, reconnectInterval : 5000}}, //always retry\n    };\n    this.conn = null;\n    this.connected = false;\n    this.logger = Logger.getLogger('memdb', __filename, 'shard:' + opts.shardId);\n};\n\nvar proto = MongoBackend.prototype;\n\nproto.start = function(){\n    var self = this;\n\n    return P.promisify(mongodb.MongoClient.connect)(this.config.url, this.config.options)\n    .then(function(ret){\n        self.conn = ret;\n        self.connected = true;\n\n        self.conn.on('close', function(){\n            self.connected = false;\n            self.logger.error('backend mongodb disconnected');\n        });\n\n        self.conn.on('reconnect', function(){\n            self.connected = true;\n            self.logger.warn('backend mongodb reconnected');\n        });\n\n        self.conn.on('error', function(err){\n            self.logger.error(err.stack);\n        });\n\n        self.logger.info('backend mongodb connected to %s', self.config.url);\n    });\n};\n\nproto.stop = function(){\n    var self = this;\n\n    this.conn.removeAllListeners('close');\n\n    return this.conn.closeAsync()\n    .then(function(){\n        self.logger.info('backend mongodb closed');\n    });\n};\n\nproto.get = function(name, id){\n    this.ensureConnected();\n    this.logger.debug('backend mongodb get(%s, %s)', name, id);\n\n    return this.conn.collection(name).findOneAsync({_id : id});\n};\n\n// Return an async iterator with .next(cb) signature\nproto.getAll = function(name){\n    this.ensureConnected();\n    this.logger.debug('backend mongodb getAll(%s)', name);\n\n    return this.conn.collection(name).findAsync();\n};\n\nproto.set = function(name, id, doc){\n    this.ensureConnected();\n    this.logger.debug('backend mongodb set(%s, %s)', name, id);\n\n    if(!!doc){\n        doc._id = id;\n        return this.conn.collection(name).updateAsync({_id : id}, doc, {upsert : true});\n    }\n    else{\n        return this.conn.collection(name).removeAsync({_id : id});\n    }\n};\n\n// items : [{name, id, doc}]\nproto.setMulti = function(items){\n    this.ensureConnected();\n    this.logger.debug('backend mongodb setMulti');\n\n    var self = this;\n    return P.mapLimit(items, function(item){\n        return self.set(item.name, item.id, item.doc);\n    });\n};\n\n// drop table or database\nproto.drop = function(name){\n    this.ensureConnected();\n    this.logger.debug('backend mongodb drop %s', name);\n\n    if(!!name){\n        return this.conn.collection(name).dropAsync()\n        .catch(function(e){\n            // Ignore ns not found error\n            if(e.message.indexOf('ns not found') === -1){\n                throw e;\n            }\n        });\n    }\n    else{\n        return this.conn.dropDatabaseAsync();\n    }\n};\n\nproto.getCollectionNames = function(){\n    return this.conn.collectionsAsync().then(function(collections){\n        return collections.map(function(collection){\n            return collection.s.name;\n        });\n    });\n};\n\nproto.ensureConnected = function(){\n    if(!this.connected){\n        throw new Error('backend mongodb not connected');\n    }\n};\n\nmodule.exports = MongoBackend;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/backends/redis-backend.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar P = require('bluebird');\nvar Logger = require('memdb-logger');\nvar redis = P.promisifyAll(require('redis'));\n\nvar RedisBackend = function(opts){\n    opts = opts || {};\n\n    this.config = {\n        host : opts.host || '127.0.0.1',\n        port : opts.port || 6379,\n        db : opts.db || 0,\n        options : opts.option || {},\n        prefix : opts.prefix || '',\n    };\n    this.conn = null;\n\n    this.logger = Logger.getLogger('memdb', __filename, 'shard:' + opts.shardId);\n};\n\nvar proto = RedisBackend.prototype;\n\nproto.start = function(){\n    this.conn = redis.createClient(this.config.port, this.config.host, {retry_max_delay : 10 * 1000});\n\n    var self = this;\n    this.conn.on('error', function(err){\n        self.logger.error(err.stack);\n    });\n\n    this.conn.select(this.config.db);\n\n    this.logger.debug('backend redis connected to %s:%s:%s', this.config.host, this.config.port, this.config.db);\n};\n\nproto.stop = function(){\n    this.logger.debug('backend redis stop');\n    return this.conn.quitAsync();\n};\n\nproto.get = function(name, id){\n    this.logger.debug('backend redis get(%s, %s)', name, id);\n\n    return P.bind(this)\n    .then(function(){\n        return this.conn.hmgetAsync(this.config.prefix + name, id);\n    })\n    .then(function(ret){\n        ret = ret[0];\n        return JSON.parse(ret);\n    });\n};\n\n// Return an async iterator with .next(cb) signature\nproto.getAll = function(name){\n    throw new Error('not implemented');\n};\n\n// delete when doc is null\nproto.set = function(name, id, doc){\n    this.logger.debug('backend redis set(%s, %s)', name, id);\n\n    if(!!doc){\n        return this.conn.hmsetAsync(this.config.prefix + name, id, JSON.stringify(doc));\n    }\n    else{\n        return this.conn.hdelAsync(this.config.prefix + name, id);\n    }\n};\n\n// items : [{name, id, doc}]\nproto.setMulti = function(items){\n    this.logger.debug('backend redis setMulti');\n\n    var multi = this.conn.multi();\n\n    var self = this;\n    items.forEach(function(item){\n        if(!!item.doc){\n            multi = multi.hmset(self.config.prefix + item.name, item.id, JSON.stringify(item.doc));\n        }\n        else{\n            multi = multi.hdel(self.config.prefix + item.name, item.id);\n        }\n    });\n    return multi.execAsync();\n};\n\n// drop table or database\nproto.drop = function(name){\n    this.logger.debug('backend redis drop %s', name);\n\n    if(!!name){\n        throw new Error('not implemented');\n        //this.conn.delAsync(this.config.prefix + name);\n    }\n    else{\n        this.conn.flushdbAsync();\n    }\n};\n\nproto.getCollectionNames = function(){\n    throw new Error('not implemented');\n};\n\nmodule.exports = RedisBackend;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/document.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar P = require('bluebird');\nvar util = require('util');\nvar utils = require('./utils');\nvar AsyncLock = require('async-lock');\nvar EventEmitter = require('events').EventEmitter;\nvar modifier = require('./modifier');\nvar logger = require('memdb-logger').getLogger('memdb', __filename);\n\nvar DEFAULT_LOCK_TIMEOUT = 10 * 1000;\n\nvar Document = function(opts){ //jshint ignore:line\n    opts = opts || {};\n\n    if(!opts.hasOwnProperty('_id')){\n        throw new Error('_id is not specified');\n    }\n    this._id = opts._id;\n\n    var doc = opts.doc || null;\n    if(typeof(doc) !== 'object'){\n        throw new Error('doc must be object');\n    }\n    if(!!doc){\n        doc._id = this._id;\n    }\n\n    this.commited = doc;\n    this.changed = undefined; // undefined means no change, while null means removed\n    this.connId = null; // Connection that hold the document lock\n\n    this.locker = opts.locker;\n    this.lockKey = opts.lockKey;\n    if(!this.locker){\n        this.locker = new AsyncLock({\n                            Promise : P,\n                            timeout : opts.lockTimeout || DEFAULT_LOCK_TIMEOUT\n                            });\n        this.lockKey = '';\n    }\n\n    this.releaseCallback = null;\n\n    this.indexes = opts.indexes || {};\n\n    this.savedIndexValues = {}; //{indexKey : indexValue}\n\n    EventEmitter.call(this);\n};\n\nutil.inherits(Document, EventEmitter);\n\nvar proto = Document.prototype;\n\nproto.find = function(connId, fields){\n    var doc = this.isLocked(connId) ? this._getChanged() : this.commited;\n\n    if(doc === null){\n        return null;\n    }\n\n    if(!fields){\n        return doc;\n    }\n\n    var includeFields = [], excludeFields = [];\n\n    if(typeof(fields) === 'string'){\n        includeFields = fields.split(' ');\n    }\n    else if(typeof(fields) === 'object'){\n        for(var field in fields){\n            if(!!fields[field]){\n                includeFields.push(field);\n            }\n            else{\n                excludeFields.push(field);\n            }\n        }\n        if(includeFields.length > 0 && excludeFields.length > 0){\n            throw new Error('Can not specify both include and exclude fields');\n        }\n    }\n\n    var ret = null;\n    if(includeFields.length > 0){\n        ret = {};\n        includeFields.forEach(function(field){\n            if(doc.hasOwnProperty(field)){\n                ret[field] = doc[field];\n            }\n        });\n        ret._id = this._id;\n    }\n    else if(excludeFields.length > 0){\n        ret = {};\n        for(var key in doc){\n            ret[key] = doc[key];\n        }\n        excludeFields.forEach(function(key){\n            delete ret[key];\n        });\n    }\n    else{\n        ret = doc;\n    }\n\n    return ret;\n};\n\nproto.exists = function(connId){\n    return this.isLocked(connId) ? this._getChanged() !== null: this.commited !== null;\n};\n\nproto.insert = function(connId, doc){\n    this.modify(connId, '$insert',  doc);\n};\n\nproto.remove = function(connId){\n    this.modify(connId, '$remove');\n};\n\nproto.update = function(connId, modifier, opts){\n    opts = opts || {};\n    if(!modifier){\n        throw new Error('modifier is empty');\n    }\n\n    modifier = modifier || {};\n\n    var isModify = false;\n    for(var field in modifier){\n        isModify = (field[0] === '$');\n        break;\n    }\n\n    if(!isModify){\n        this.modify(connId, '$replace', modifier);\n    }\n    else{\n        for(var cmd in modifier){\n            this.modify(connId, cmd, modifier[cmd]);\n        }\n    }\n};\n\nproto.modify = function(connId, cmd, param){\n    this.ensureLocked(connId);\n\n    for(var indexKey in this.indexes){\n        if(!this.savedIndexValues.hasOwnProperty(indexKey)){\n            this.savedIndexValues[indexKey] = this._getIndexValue(indexKey, this.indexes[indexKey]);\n        }\n    }\n\n    var modifyFunc = modifier[cmd];\n    if(typeof(modifyFunc) !== 'function'){\n        throw new Error('invalid modifier - ' + cmd);\n    }\n\n    if(this.changed === undefined){ //copy on write\n        this.changed = utils.clone(this.commited);\n    }\n\n    this.changed = modifyFunc(this.changed, param);\n\n    // id is immutable\n    if(!!this.changed){\n        this.changed._id = this._id;\n    }\n\n    for(indexKey in this.indexes){\n        var value = this._getIndexValue(indexKey, this.indexes[indexKey]);\n\n        if(value !== this.savedIndexValues[indexKey]){\n            logger.trace('%s.updateIndex(%s, %s, %s)', this._id, indexKey, this.savedIndexValues[indexKey], value);\n            this.emit('updateIndex', connId, indexKey, this.savedIndexValues[indexKey], value);\n\n            this.savedIndexValues[indexKey] = value;\n        }\n    }\n\n    logger.trace('%s.modify(%s, %j) => %j', this._id, cmd, param, this.changed);\n};\n\nproto.lock = function(connId){\n    if(connId === null || connId === undefined){\n        throw new Error('connId is null');\n    }\n\n    var deferred = P.defer();\n    if(this.isLocked(connId)){\n        deferred.resolve();\n    }\n    else{\n        var self = this;\n        this.locker.acquire(this.lockKey, function(release){\n            self.connId = connId;\n            self.releaseCallback = release;\n\n            self.emit('lock');\n            deferred.resolve();\n        })\n        .catch(function(err){\n            if(!deferred.isResolved()){\n                deferred.reject(new Error('doc.lock failed - ' + self.lockKey));\n            }\n        });\n    }\n    return deferred.promise;\n};\n\n// Wait existing lock release (not create new lock)\nproto._waitUnlock = function(){\n    var deferred = P.defer();\n    var self = this;\n    this.locker.acquire(this.lockKey, function(){\n        deferred.resolve();\n    })\n    .catch(function(err){\n        deferred.reject(new Error('doc._waitUnlock failed - ' + self.lockKey));\n    });\n    return deferred.promise;\n};\n\nproto._unlock = function(){\n    if(this.connId === null){\n        return;\n    }\n\n    this.connId = null;\n    var releaseCallback = this.releaseCallback;\n    this.releaseCallback = null;\n\n    releaseCallback();\n\n    this.emit('unlock');\n};\n\nproto._getChanged = function(){\n    return this.changed !== undefined ? this.changed : this.commited;\n};\n\nproto._getCommited = function(){\n    return this.commited;\n};\n\nproto.commit = function(connId){\n    this.ensureLocked(connId);\n\n    if(this.changed !== undefined){\n        this.commited = this.changed;\n    }\n    this.changed = undefined;\n\n    this.emit('commit');\n    this._unlock();\n};\n\nproto.rollback = function(connId){\n    this.ensureLocked(connId);\n\n    this.changed = undefined;\n\n    this.savedIndexValues = {};\n\n    this.emit('rollback');\n    this._unlock();\n};\n\nproto.ensureLocked = function(connId){\n    if(!this.isLocked(connId)){\n        throw new Error('doc not locked by ' + connId);\n    }\n};\n\nproto.isLocked = function(connId){\n    return this.connId === connId && connId !== null && connId !== undefined;\n};\n\nproto.isFree = function(){\n    return this.connId === null;\n};\n\nproto._getIndexValue = function(indexKey, opts){\n    opts = opts || {};\n\n    var self = this;\n    var indexValue = JSON.parse(indexKey).sort().map(function(key){\n        var doc = self._getChanged();\n        var value = !!doc ? doc[key] : undefined;\n        // null and undefined is not included in index\n        if(value === null || value === undefined){\n            return undefined;\n        }\n        if(['number', 'string', 'boolean'].indexOf(typeof(value)) === -1){\n            throw new Error('invalid value for indexed key ' + indexKey);\n        }\n        var ignores = opts.valueIgnore ? opts.valueIgnore[key] || [] : [];\n        if(ignores.indexOf(value) !== -1){\n            return undefined;\n        }\n        return value;\n    });\n\n    // Return null if one of the value is undefined\n    if(indexValue.indexOf(undefined) !== -1){\n        return null;\n    }\n    return JSON.stringify(indexValue);\n};\n\nmodule.exports = Document;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/modifier.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar utils = require('./utils');\n\n//http://docs.mongodb.org/manual/reference/limits/#Restrictions-on-Field-Names\nvar verifyDoc = function(doc){\n    if(doc === null || typeof(doc) !== 'object'){\n        return;\n    }\n\n    for(var key in doc){\n        if(key[0] === '$'){\n            throw new Error('Document fields can not start with \"$\"');\n        }\n        if(key.indexOf('.') !== -1){\n            throw new Error('Document fields can not contain \".\"');\n        }\n        verifyDoc(doc[key]);\n    }\n};\n\nexports.$insert = function(doc, param){\n    param = param || {};\n    if(doc !== null){\n        throw new Error('doc already exists');\n    }\n    verifyDoc(param);\n    return param;\n};\n\nexports.$replace = function(doc, param){\n    param = param || {};\n    if(doc === null){\n        throw new Error('doc not exist');\n    }\n    verifyDoc(param);\n    return param;\n};\n\nexports.$remove = function(doc, param){\n    if(doc === null){\n        throw new Error('doc not exist');\n    }\n    return null;\n};\n\nexports.$set = function(doc, param){\n    if(doc === null){\n        throw new Error('doc not exist');\n    }\n    for(var path in param){\n        verifyDoc(param[path]);\n        utils.setObjPath(doc, path, param[path]);\n    }\n    return doc;\n};\n\nexports.$unset = function(doc, param){\n    if(doc === null){\n        throw new Error('doc not exist');\n    }\n    for(var path in param){\n        if(!!param[path]){\n            utils.deleteObjPath(doc, path);\n        }\n    }\n    return doc;\n};\n\nexports.$inc = function(doc, param){\n    if(doc === null){\n        throw new Error('doc not exist');\n    }\n    for(var path in param){\n        var value = utils.getObjPath(doc, path);\n        var delta = param[path];\n        if(value === undefined){\n            value = 0;\n        }\n        if(typeof(value) !== 'number' || typeof(delta) !== 'number'){\n            throw new Error('$inc non-number');\n        }\n        utils.setObjPath(doc, path, value + delta);\n    }\n    return doc;\n};\n\nexports.$push = function(doc, param){\n    if(doc === null){\n        throw new Error('doc not exist');\n    }\n    for(var path in param){\n        var arr = utils.getObjPath(doc, path);\n        if(arr === undefined){\n            utils.setObjPath(doc, path, []);\n            arr = utils.getObjPath(doc, path);\n        }\n        if(!Array.isArray(arr)){\n            throw new Error('$push to non-array');\n        }\n        verifyDoc(param[path]);\n        arr.push(param[path]);\n    }\n    return doc;\n};\n\nexports.$pushAll = function(doc, param){\n    if(doc === null){\n        throw new Error('doc not exist');\n    }\n    for(var path in param){\n        var arr = utils.getObjPath(doc, path);\n        if(arr === undefined){\n            utils.setObjPath(doc, path, []);\n            arr = utils.getObjPath(doc, path);\n        }\n        if(!Array.isArray(arr)){\n            throw new Error('$push to non-array');\n        }\n        var items = param[path];\n        if(!Array.isArray(items)){\n            items = [items];\n        }\n        for(var i in items){\n            verifyDoc(items[i]);\n            arr.push(items[i]);\n        }\n    }\n    return doc;\n};\n\nexports.$addToSet = function(doc, param){\n    if(doc === null){\n        throw new Error('doc not exist');\n    }\n    for(var path in param){\n        var arr = utils.getObjPath(doc, path);\n        if(arr === undefined){\n            utils.setObjPath(doc, path, []);\n            arr = utils.getObjPath(doc, path);\n        }\n        if(!Array.isArray(arr)){\n            throw new Error('$addToSet to non-array');\n        }\n        var value = param[path];\n        if(arr.indexOf(value) === -1){\n            verifyDoc(value);\n            arr.push(value);\n        }\n    }\n    return doc;\n};\n\nexports.$pop = function(doc, param){\n    if(doc === null){\n        throw new Error('doc not exist');\n    }\n    for(var path in param){\n        var arr = utils.getObjPath(doc, path);\n        if(Array.isArray(arr)){\n            arr.pop();\n        }\n    }\n    return doc;\n};\n\nexports.$pull = function(doc, param){\n    if(doc === null){\n        throw new Error('doc not exist');\n    }\n    for(var path in param){\n        var arr = utils.getObjPath(doc, path);\n        if(Array.isArray(arr)){\n            var value = param[path];\n            var i = arr.indexOf(value);\n            if(i !== -1){\n                arr.splice(i, 1);\n            }\n        }\n    }\n    return doc;\n};\n\nexports.$pullAll = function(doc, param){\n    if(doc === null){\n        throw new Error('doc not exist');\n    }\n    for(var path in param){\n        var arr = utils.getObjPath(doc, path);\n        if(Array.isArray(arr)){\n            var values = param[path];\n            if(!Array.isArray(values)){\n                values = [values];\n            }\n            values.forEach(function(value){\n                var i = arr.indexOf(value);\n                if(i !== -1){\n                    arr.splice(i, 1);\n                }\n            }); //jshint ignore:line\n        }\n    }\n    return doc;\n};\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/slave.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar P = require('bluebird');\nvar Logger = require('memdb-logger');\nvar redis = P.promisifyAll(require('redis'));\nvar utils = require('./utils');\n\nvar Slave = function(opts){\n    opts = opts || {};\n\n    this.shardId = opts.shardId;\n\n    this.config = {\n        host : opts.host || '127.0.0.1',\n        port : opts.port || 6379,\n        db : opts.db || 0,\n        options : opts.options || {},\n    };\n\n    this.client = null;\n    this.logger = Logger.getLogger('memdb', __filename, 'shard:' + this.shardId);\n};\n\nvar proto = Slave.prototype;\n\nproto.start = function(){\n    return P.bind(this)\n    .then(function(){\n        this.client = redis.createClient(this.config.port, this.config.host, this.config.options);\n        var self = this;\n        this.client.on('error', function(err){\n            self.logger.error(err.stack);\n        });\n        return this.client.selectAsync(this.config.db);\n    })\n    .then(function(){\n        this.logger.info('slave started %s:%s:%s', this.config.host, this.config.port, this.config.db);\n    });\n};\n\nproto.stop = function(){\n    return P.bind(this)\n    .then(function(){\n        return this.client.quitAsync();\n    })\n    .then(function(){\n        this.logger.info('slave stoped');\n    });\n};\n\nproto.set = function(key, doc){\n    this.logger.debug('slave set %s', key);\n    return this.client.setAsync(this._redisKey(key), JSON.stringify(doc));\n};\n\nproto.del = function(key){\n    this.logger.debug('slave del %s', key);\n    return this.client.delAsync(this._redisKey(key));\n};\n\n// docs - {key : doc}\nproto.setMulti = function(docs){\n    this.logger.debug('slave setMulti');\n\n    var multi = this.client.multi();\n    for(var key in docs){\n        var doc = docs[key];\n        multi = multi.set(this._redisKey(key), JSON.stringify(doc));\n    }\n\n    return multi.execAsync();\n};\n\n// returns - {key : doc}\nproto.getMulti = function(keys){\n    this.logger.debug('slave getMulti');\n\n    var self = this;\n    var multi = this.client.multi();\n    keys.forEach(function(key){\n        multi = multi.get(self._redisKey(key));\n    });\n\n    return multi.execAsync()\n    .then(function(results){\n        var docs = {};\n        for(var i in keys){\n            var key = keys[i];\n            if(!!results[i]){\n                docs[key] = JSON.parse(results[i]);\n            }\n        }\n        return docs;\n    });\n};\n\nproto.getAllKeys = function(){\n    this.logger.debug('slave getAllKeys');\n\n    return P.bind(this)\n    .then(function(){\n        return this.client.keysAsync(this._redisKey('*'));\n    })\n    .then(function(keys){\n        var self = this;\n        return keys.map(function(key){\n            return self._extractKey(key);\n        });\n    });\n};\n\nproto.clear = function(){\n    this.logger.debug('slave clear');\n\n    return P.bind(this)\n    .then(function(){\n        return this.client.keysAsync(this._redisKey('*'));\n    })\n    .then(function(keys){\n        var multi = this.client.multi();\n        keys.forEach(function(key){\n            multi = multi.del(key);\n        });\n        return multi.execAsync();\n    });\n};\n\nproto._redisKey = function(key){\n    return 'bk$' + this.shardId + '$' + key;\n};\n\nproto._extractKey = function(existKey){\n    var words = existKey.split('$');\n    return words.slice(2, words.length).join('$');\n};\n\nmodule.exports = Slave;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/indexbuilder.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\n/**\n * WARNING: Shutdown all cluster before running these scripts\n */\n\nvar P = require('bluebird');\nvar backends = require('./backends');\nvar BackendLocker = require('./backendlocker');\nvar Document = require('./document'); //jshint ignore:line\nvar Collection = require('./collection');\nvar utils = require('./utils');\nvar logger = require('memdb-logger').getLogger('memdb', __filename);\n\nvar ensureShutDown = function(lockingConf){\n    lockingConf.shardId = '$';\n    lockingConf.heartbeatInterval = 0;\n    var backendLocker = new BackendLocker(lockingConf);\n\n    return P.try(function(){\n        return backendLocker.start();\n    })\n    .then(function(){\n        return backendLocker.getActiveShards();\n    })\n    .then(function(shardIds){\n        if(shardIds.length > 0){\n            throw new Error('You should shutdown all shards first');\n        }\n    })\n    .finally(function(){\n        return backendLocker.stop();\n    });\n};\n\n// dropIndex('field1 field2')\nexports.drop = function(conf, collName, keys){\n    if(!Array.isArray(keys)){\n        keys = keys.split(' ');\n    }\n    var indexKey = JSON.stringify(keys.sort());\n    conf.backend.shardId = '$';\n    var backend = backends.create(conf.backend);\n    var indexCollName = Collection.prototype._indexCollectionName.call({name : collName}, indexKey);\n\n    return ensureShutDown(conf.locking)\n    .then(function(){\n        return backend.start();\n    })\n    .then(function(){\n        return backend.drop(indexCollName);\n    })\n    .finally(function(){\n        logger.warn('Droped index %s %s', collName, indexKey);\n        return backend.stop();\n    });\n};\n\n// rebuildIndex('field1 field2', {unique : true})\nexports.rebuild = function(conf, collName, keys, opts){\n    opts = opts || {};\n    if(!Array.isArray(keys)){\n        keys = keys.split(' ');\n    }\n    var indexKey = JSON.stringify(keys.sort());\n    conf.backend.shardId = '$';\n    var backend = backends.create(conf.backend);\n\n    var indexCollName = Collection.prototype._indexCollectionName.call({name : collName}, indexKey);\n\n    logger.warn('Start rebuild index %s %s', collName, indexKey);\n\n    return ensureShutDown(conf.locking)\n    .then(function(){\n        return backend.start();\n    })\n    .then(function(){\n        return backend.drop(indexCollName);\n    })\n    .then(function(){\n        return backend.getAll(collName);\n    })\n    .then(function(itor){\n        return utils.mongoForEach(itor, function(item){\n            var indexValue = Document.prototype._getIndexValue.call({_getChanged : function(){return item;}}, indexKey, opts);\n            if(!indexValue){\n                return;\n            }\n\n            return P.try(function(){\n                return backend.get(indexCollName, indexValue);\n            })\n            .then(function(doc){\n                if(!doc){\n                    doc = {_id: indexValue, ids : []};\n                }\n                else if(opts.unique){\n                    throw new Error('Duplicate value for unique key ' + indexKey);\n                }\n\n                if(doc.ids.indexOf(item._id) === -1){\n                    doc.ids.push(item._id);\n                }\n                return backend.set(indexCollName, indexValue, doc);\n            });\n        });\n    })\n    .then(function(){\n        logger.warn('Finish rebuild index %s %s', collName, indexKey);\n        return backend.stop();\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/protocol.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar P = require('bluebird');\nvar logger = require('memdb-logger').getLogger('memdb', __filename);\n\nvar DEFAULT_MAX_MSG_LENGTH = 1024 * 1024;\n\nvar Protocol = function(opts){\n    EventEmitter.call(this);\n\n    opts = opts || {};\n\n    this.socket = opts.socket;\n    this.socket.setEncoding('utf8');\n\n    this.maxMsgLength = opts.maxMsgLength || DEFAULT_MAX_MSG_LENGTH;\n\n    this.remainLine = '';\n\n    var self = this;\n    this.socket.on('data', function(data){\n        // message is json encoded and splited by '\\n'\n        var lines = data.split('\\n');\n        for(var i=0; i<lines.length - 1; i++){\n            try{\n                var msg = '';\n                if(i === 0){\n                    msg = JSON.parse(self.remainLine + lines[i]);\n                    self.remainLine = '';\n                }\n                else{\n                    msg = JSON.parse(lines[i]);\n                }\n                self.emit('msg', msg);\n            }\n            catch(err){\n                logger.error(err.stack);\n            }\n        }\n        self.remainLine = lines[lines.length - 1];\n    });\n\n    this.socket.on('close', function(hadError){\n        self.emit('close', hadError);\n    });\n\n    this.socket.on('connect', function(){\n        self.emit('connect');\n    });\n\n    this.socket.on('error', function(err){\n        self.emit('error', err);\n    });\n\n    this.socket.on('timeout', function(){\n        self.emit('timeout');\n    });\n};\n\nutil.inherits(Protocol, EventEmitter);\n\nProtocol.prototype.send = function(msg){\n    var data = JSON.stringify(msg) + '\\n';\n    if(data.length > this.maxMsgLength){\n        throw new Error('msg length exceed limit');\n    }\n\n    var ret = this.socket.write(data);\n    if(!ret){\n        logger.warn('socket.write return false');\n    }\n};\n\nProtocol.prototype.disconnect = function(){\n    this.socket.end();\n};\n\nmodule.exports = Protocol;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/app/server.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar Database = require('./database');\nvar memdbLogger = require('memdb-logger');\nvar net = require('net');\nvar http = require('http');\nvar P = require('bluebird');\nvar uuid = require('node-uuid');\nvar Protocol = require('./protocol');\nvar utils = require('./utils');\nvar consts = require('./consts');\n\nvar DEFAULT_PORT = 31017;\n\nexports.start = function(opts){\n    var deferred = P.defer();\n\n    var logger = memdbLogger.getLogger('memdb', __filename, 'shard:' + opts.shardId);\n    logger.warn('starting %s...', opts.shardId);\n\n    var bind = opts.bind || '0.0.0.0';\n    var port = opts.port || DEFAULT_PORT;\n\n    var db = new Database(opts);\n\n    var sockets = utils.forceHashMap();\n\n    var _isShutingDown = false;\n\n    var server = net.createServer(function(socket){\n\n        var clientId = uuid.v4();\n        sockets[clientId] = socket;\n\n        var connIds = utils.forceHashMap();\n        var remoteAddress = socket.remoteAddress;\n        var protocol = new Protocol({socket : socket});\n\n        protocol.on('msg', function(msg){\n            logger.debug('[conn:%s] %s => %j', msg.connId, remoteAddress, msg);\n            var resp = {seq : msg.seq};\n\n            P.try(function(){\n                if(msg.method === 'connect'){\n                    var clientVersion = msg.args[0];\n                    if(parseFloat(clientVersion) < parseFloat(consts.minClientVersion)){\n                        throw new Error('client version not supported, please upgrade');\n                    }\n                    var connId = db.connect().connId;\n                    connIds[connId] = true;\n                    return {\n                        connId : connId,\n                    };\n                }\n                if(!msg.connId){\n                    throw new Error('connId is required');\n                }\n                if(msg.method === 'disconnect'){\n                    return db.disconnect(msg.connId)\n                    .then(function(){\n                        delete connIds[msg.connId];\n                    });\n                }\n                return db.execute(msg.connId, msg.method, msg.args);\n            })\n            .then(function(ret){\n                resp.err = null;\n                resp.data = ret;\n            }, function(err){\n                resp.err = {\n                    message : err.message,\n                    stack : err.stack,\n                };\n                resp.data = null;\n            })\n            .then(function(){\n                protocol.send(resp);\n                logger.debug('[conn:%s] %s <= %j', msg.connId, remoteAddress, resp);\n            })\n            .catch(function(e){\n                logger.error(e.stack);\n            });\n        });\n\n        protocol.on('close', function(){\n            P.map(Object.keys(connIds), function(connId){\n                return db.disconnect(connId);\n            })\n            .then(function(){\n                connIds = utils.forceHashMap();\n                delete sockets[clientId];\n                logger.info('client %s disconnected', remoteAddress);\n            })\n            .catch(function(e){\n                logger.error(e.stack);\n            });\n        });\n\n        protocol.on('error', function(e){\n            logger.error(e.stack);\n        });\n\n        logger.info('client %s connected', remoteAddress);\n    });\n\n    server.on('error', function(err){\n        logger.error(err.stack);\n\n        if(!deferred.isResolved()){\n            deferred.reject(err);\n        }\n    });\n\n    P.try(function(){\n        return P.promisify(server.listen, server)(port, bind);\n    })\n    .then(function(){\n        return db.start();\n    })\n    .then(function(){\n        logger.warn('server started on %s:%s', bind, port);\n        deferred.resolve();\n    })\n    .catch(function(err){\n        logger.error(err.stack);\n        deferred.reject(err);\n    });\n\n    var shutdown = function(){\n        logger.warn('receive shutdown signal');\n\n        if(_isShutingDown){\n            return;\n        }\n        _isShutingDown = true;\n\n        return P.try(function(){\n            var deferred = P.defer();\n\n            server.once('close', function(){\n                logger.debug('on server close');\n                deferred.resolve();\n            });\n\n            server.close();\n\n            Object.keys(sockets).forEach(function(id){\n                try{\n                    sockets[id].end();\n                    sockets[id].destroy();\n                }\n                catch(e){\n                    logger.error(e.stack);\n                }\n            });\n\n            return deferred.promise;\n        })\n        .then(function(){\n            return db.stop();\n        })\n        .catch(function(e){\n            logger.error(e.stack);\n        })\n        .finally(function(){\n            logger.warn('server closed');\n            memdbLogger.shutdown(function(){\n                process.exit(0);\n            });\n        });\n    };\n\n    process.on('SIGTERM', shutdown);\n    process.on('SIGINT', shutdown);\n\n    process.on('uncaughtException', function(err) {\n        logger.error('Uncaught exception: %s', err.stack);\n    });\n\n    return deferred.promise;\n};\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/lib/mdbgoose.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\nvar path = require('path');\nglobal.MONGOOSE_DRIVER_PATH = '../../../../lib/mongoose-driver'; // path.join(__dirname, 'mongoose-driver');\nvar P = require('bluebird');\nvar util = require('util');\nvar logger = require('memdb-logger').getLogger('memdb-client', __filename);\nvar memdb = require('./index');\n\nvar mongoose = require('mongoose');\n\n// save original connect\nvar connectMongo = mongoose.connect;\nvar disconnectMongo = mongoose.disconnect;\n\nmongoose.connect = function(opts){\n    var promise = P.bind(this)\n    .then(function(){\n        if(this._autoconn){\n            throw new Error('Already connected');\n        }\n        return memdb.autoConnect(opts);\n    })\n    .then(function(ret){\n        this._autoconn = ret;\n\n        if(opts && opts.backend){\n            return P.promisify(connectMongo, mongoose)(opts.backend.url);\n        }\n    });\n\n    var cb = arguments[arguments.length - 1];\n    if(typeof(cb) === 'function'){\n        return promise.nodeify(cb);\n    }\n    else{\n        return promise;\n    }\n};\n\nmongoose.disconnect = function(){\n    var promise = P.bind(this)\n    .then(function(){\n        return this.autoconn.close();\n    })\n    .then(function(){\n        this._autoconn = null;\n        return P.promisify(disconnectMongo, mongoose)();\n    });\n\n    var cb = arguments[arguments.length - 1];\n    if(typeof(cb) === 'function'){\n        return promise.nodeify(cb);\n    }\n    else{\n        return promise;\n    }\n};\n\nObject.defineProperty(mongoose, 'autoconn' , {\n    get : function(){\n        if(!mongoose._autoconn){\n            throw new Error('Please connect first');\n        }\n        return mongoose._autoconn;\n    }\n});\n\nmongoose.transaction = function(func, shardId, cb){\n    var promise = this.autoconn.transaction(func, shardId);\n\n    if(typeof(cb) === 'function'){\n        return promise.nodeify(cb);\n    }\n    else{\n        return promise;\n    }\n};\n\n// Parse mongoose model to generate collection config (indexes)\nmongoose.genCollectionConfig = function(){\n    var collections = {};\n\n    for(var name in mongoose.models){\n        var model = mongoose.models[name];\n        var schema = model.schema;\n        var collname = model.collection.name;\n\n        if(!collections[collname]){\n            collections[collname] = {};\n        }\n        var collection = collections[collname];\n        if(!collection.indexes){\n            collection.indexes = [];\n        }\n\n        var paths = schema.paths;\n        var index = null, mdbIndex = null;\n        for(var field in paths){\n            if(field === '_id' || field.indexOf('.') !== -1){\n                continue; //ignore compound field and _id\n            }\n            index = paths[field]._index;\n            if(!!index){\n                mdbIndex = {keys : [field]};\n                if(!!index.unique){\n                    mdbIndex.unique = true;\n                }\n\n                mdbIndex.valueIgnore = {};\n                mdbIndex.valueIgnore[field] = paths[field].options.indexIgnore || [];\n                collection.indexes.push(mdbIndex);\n            }\n        }\n\n        if(!!schema._indexes){\n            for(var i in schema._indexes){\n                index = schema._indexes[i];\n                mdbIndex = {keys : [], valueIgnore : {}};\n                for(field in index[0]){\n                    if(index[0][field]){\n                        mdbIndex.keys.push(field);\n                        mdbIndex.valueIgnore[field] = paths[field].options.indexIgnore || [];\n                    }\n                }\n                if(index[1] && !!index[1].unique){\n                    mdbIndex.unique = true;\n                }\n                collection.indexes.push(mdbIndex);\n            }\n        }\n\n        //Disable versionkey\n        schema.options.versionKey = false;\n    }\n\n    logger.info('parsed collection config : %j', collections);\n    return collections;\n};\n\n\nvar Model = mongoose.Model;\n\nModel.findMongo = function(){\n    return this.find.apply(this, [].slice.call(arguments)).comment('$mongo');\n};\n\nModel.findOneMongo = function(){\n    return this.findOne.apply(this, [].slice.call(arguments)).comment('$mongo');\n};\n\nModel.findByIdMongo = function(){\n    return this.findById.apply(this, [].slice.call(arguments)).comment('$mongo');\n};\n\nModel.findReadOnly = function(){\n    return this.find.apply(this, [].slice.call(arguments)).comment('$readonly');\n};\n\nModel.findOneReadOnly = function(){\n    return this.findOne.apply(this, [].slice.call(arguments)).comment('$readonly');\n};\n\nModel.findByIdReadOnly = function(){\n    return this.findById.apply(this, [].slice.call(arguments)).comment('$readonly');\n};\n\nModel.countMongo = function(query, cb){\n    if(!query){\n        query = {};\n    }\n    return this.collection.countMongo(query, {}, cb);\n};\n\nvar overwrited = ['findByIdAndRemove', 'findByIdAndUpdate', 'findOneAndUpdate', 'findOneAndRemove'];\n\nfor (var i = overwrited.length - 1; i >= 0; i--) {\n    (function(funcName){\n        mongoose.Model[funcName] = function(){\n            var cb = arguments[arguments.length-1];\n            if(typeof(cb) === 'function') {\n                cb(new Error(util.format('not implemented method: ', funcName)));\n            } else {\n                throw new Error(util.format('not implemented method: ', funcName));\n            }\n        };\n    })(overwrited[i]); //jshint ignore:line\n}\n\nmodule.exports = P.promisifyAll(mongoose);\n\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/sample/indexing.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\n// Add the following index config in memdb.conf.js and restart memdbcluster\n//\n// collections : {\n//     player : {\n//         indexes : [\n//             {\n//                 keys : ['areaId'],\n//                 valueIgnore : {\n//                     areaId : ['', -1],\n//                 },\n//             },\n//             {\n//                 keys : ['deviceType', 'deviceId'],\n//                 unique : true,\n//             },\n//         ]\n//     }\n// },\n\n// npm install memdb-client\n// run with node >= 0.12 with --harmony option\n\n// We assume you have started shard 's1' on localhost:31017\n\nvar memdb = require('memdb-client');\nvar P = memdb.Promise;\nvar should = require('should');\n\nvar main = P.coroutine(function*(){\n    // Connect to memdb\n    var autoconn = yield memdb.autoConnect({\n        shards : {s1 : {host : '127.0.0.1', port : 31017}}\n    });\n\n    var Player = autoconn.collection('player');\n\n    // make transaction in shard s1\n    yield autoconn.transaction(P.coroutine(function*(){\n        // Insert players\n        var players = [{_id : 'p1', name : 'rain', areaId : 1},\n                       {_id : 'p2', name : 'snow', areaId : 2}];\n        yield Player.insert(players);\n\n        // Find all players in area1\n        var docs = yield Player.find({areaId : 1});\n        docs.length.should.eql(1);\n        docs[0].areaId.should.eql(1);\n\n        // Find doc of id p1, return one doc\n        var doc = yield Player.find('p1');\n        doc._id.should.eql('p1');\n\n        // DO NOT do this! Error will be thrown since name is not indexed.\n        // yield Player.find({name : 'rain'});\n\n        // Move all players in area1 into area2\n        yield Player.update({areaId : 1}, {$set : {areaId : 2}});\n        // Remove all players in area2\n        yield Player.remove({areaId : 2});\n    }), 's1');\n\n    // make transaction in shard s1\n    yield autoconn.transaction(P.coroutine(function*(){\n        // Insert a player\n        yield Player.insert({_id : 'p1', deviceType : 1, deviceId : 'id1'});\n\n        // Find with compound key\n        var docs = yield Player.find({deviceType : 1, deviceId : 'id1'});\n        docs.length.should.eql(1);\n        docs[0]._id.should.eql('p1');\n\n        // Will throw duplicate key error\n        // yield Player.insert({deviceType : 1, deviceId : 'id1'});\n\n        // Remove player\n        yield Player.remove('p1');\n    }), 's1');\n});\n\nif (require.main === module) {\n    main().finally(process.exit);\n}\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/sample/node_modules/memdb-client/index.js":"'use strict';\nmodule.exports = require('./lib');\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/sample/node_modules/memdb-client/lib/index.js":"'use strict';\n\nvar P = require('bluebird');\nvar Connection = require('./connection');\nvar AutoConnection = require('./autoconnection');\n\nexports.connect = function(opts){\n    var conn = new Connection(opts);\n    return P.try(function(){\n        return conn.connect();\n    })\n    .thenReturn(conn);\n};\n\nexports.autoConnect = function(opts){\n    var conn = new AutoConnection(opts);\n    return P.resolve(conn);\n};\n\nexports.connectBackend = function(backend){\n    var mongodb = P.promisifyAll(require('mongodb'));\n    return P.promisify(mongodb.MongoClient.connect)(backend.url, backend.options)\n    .then(function(db){\n        var getCollection = db.collection;\n        db.collection = function(){\n            var coll = getCollection.apply(db, arguments);\n            var disabledMethods = ['createIndex', 'drop', 'dropIndex', 'dropIndexes', 'ensureIndex',\n            'findAndModify', 'getCollection', 'getDB', 'insert', 'remove', 'renameCollection', 'save', 'update'];\n            disabledMethods.forEach(function(method){\n                coll[method] = function(){\n                    throw new Error('write to backend is forbidden');\n                };\n            });\n            return coll;\n        };\n        return db;\n    });\n};\n\nObject.defineProperty(exports, 'goose', {\n    get : function(){\n        return require('./mdbgoose');\n    },\n});\n\nObject.defineProperty(exports, 'logger', {\n    get : function(){\n        return require('memdb-logger');\n    },\n});\n\nObject.defineProperty(exports, 'Promise', {\n    get : function(){\n        return require('bluebird');\n    },\n});\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/sample/node_modules/memdb-client/lib/connection.js":"'use strict';\n\nvar P = require('bluebird');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar clientPool = require('./clientpool');\nvar consts = require('./consts');\nvar logger = require('memdb-logger').getLogger('memdb-client', __filename);\n\nvar Connection = function(opts){\n    EventEmitter.call(this);\n\n    opts = opts || {};\n    this.config = opts;\n    this._client = null;\n    this._connId = null;\n\n    this._collections = {};\n};\n\nutil.inherits(Connection, EventEmitter);\n\nvar proto = Connection.prototype;\n\nproto.connect = function(){\n    if(this._connId){\n        throw new Error('already connected');\n    }\n    var key = this.config.host + ':' + this.config.port;\n\n    return P.bind(this)\n    .then(function(){\n        return clientPool.getClient(this.config.host, this.config.port);\n    })\n    .then(function(client){\n        this._client = client;\n        this._client.on('close', this._close.bind(this));\n\n        return this._client.request(null, 'connect', [consts.version]);\n    })\n    .then(function(ret){\n        this._connId = ret.connId;\n\n        logger.info('[conn:%s] connected on %s:%s', this._connId, this.config.host, this.config.port);\n        return this._connId;\n    });\n};\n\nproto.close = function(){\n    if(!this._connId){\n        throw new Error('not connected');\n    }\n    return P.bind(this)\n    .then(function(){\n        return this._client.request(this._connId, 'disconnect', []);\n    })\n    .then(function(){\n        this._close();\n    });\n};\n\nproto._close = function(){\n    logger.info('[conn:%s] closed on %s:%s', this._connId, this.config.host, this.config.port);\n\n    this._client = null;\n    this._connId = null;\n    this.emit('close');\n};\n\nproto.collection = function(name){\n    var self = this;\n    if(!this._collections[name]){\n        var collection = {};\n\n        consts.collMethods.forEach(function(method){\n            collection[method] = function(){\n                var args = [name].concat([].slice.call(arguments));\n                return self[method].apply(self, args);\n            };\n        });\n\n        this._collections[name] = collection;\n    }\n    return this._collections[name];\n};\n\nconsts.connMethods.concat(consts.collMethods).forEach(function(method){\n    proto[method] = function(){\n        if(!this._connId){\n            throw new Error('not connected');\n        }\n        var args = [].slice.call(arguments);\n        return this._client.request(this._connId, method, args);\n    };\n});\n\nmodule.exports = Connection;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/sample/node_modules/memdb-client/lib/clientpool.js":"'use strict';\n\nvar P = require('bluebird');\nvar AsyncLock = require('async-lock');\nvar Client = require('./client');\nvar logger = require('memdb-logger').getLogger('memdb-client', __filename);\n\nvar clients = {}; // {'host:port' : client}\nvar connectLock = new AsyncLock();\n\nexports.getClient = function(host, port){\n    var key = host + ':' + port;\n\n    return connectLock.acquire(key, function(){\n        if(clients[key]){\n            return clients[key];\n        }\n\n        var client = new Client();\n        client.setMaxListeners(1025);\n\n        return P.try(function(){\n            return client.connect(host, port);\n        })\n        .then(function(){\n            clients[key] = client;\n\n            client.on('close', function(){\n                delete clients[key];\n            });\n            return client;\n        });\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/sample/node_modules/memdb-client/lib/client.js":"'use strict';\n\nvar P = require('bluebird');\nvar util = require('util');\nvar net = require('net');\nvar EventEmitter = require('events').EventEmitter;\nvar Protocol = require('./protocol');\nvar logger = require('memdb-logger').getLogger('memdb-client', __filename);\n\nvar Client = function(){\n    EventEmitter.call(this);\n\n    this.protocol = null;\n    this.seq = 1;\n    this.requests = {}; //{seq : deferred}\n    this.domains = {}; //{seq : domain} saved domains\n\n    this.disconnectDeferred = null;\n};\n\nutil.inherits(Client, EventEmitter);\n\nvar proto = Client.prototype;\n\nproto.connect = function(host, port){\n    if(!!this.protocol){\n        throw new Error('connect already called');\n    }\n\n    var self = this;\n    logger.debug('start connect to %s:%s', host, port);\n\n    var connectDeferred = P.defer();\n\n    var socket = net.createConnection(port, host);\n\n    this.protocol = new Protocol({socket : socket});\n\n    this.protocol.once('connect', function(){\n        logger.info('connected to %s:%s', host, port);\n        connectDeferred.resolve();\n    });\n\n    this.protocol.on('close', function(){\n        logger.info('disconnected from %s:%s', host, port);\n\n        // reject all remaining requests\n        for(var seq in self.requests){\n            process.domain = self.domains[seq];\n            self.requests[seq].reject(new Error('connection closed'));\n        }\n        self.requests = {};\n        self.domains = {};\n\n        // Server will not disconnect if the client process exit immediately\n        // So delay resolve promise\n        if(self.disconnectDeferred){\n            setTimeout(function(){\n                self.disconnectDeferred.resolve();\n            }, 1);\n        }\n        self.protocol = null;\n\n        self.emit('close');\n    });\n\n    this.protocol.on('msg', function(msg){\n        var request = self.requests[msg.seq];\n        if(!request){\n            return;\n        }\n\n        // restore saved domain\n        process.domain = self.domains[msg.seq];\n\n        if(!msg.err){\n            logger.info('%s:%s => %j', host, port, msg);\n            request.resolve(msg.data);\n        }\n        else{\n            logger.error('%s:%s => %j', host, port, msg);\n            request.reject(msg.err);\n        }\n        delete self.requests[msg.seq];\n        delete self.domains[msg.seq];\n    });\n\n    this.protocol.on('error', function(err){\n        if(!connectDeferred.isResolved()){\n            connectDeferred.reject(err);\n        }\n        // Reject all pending requests\n        Object.keys(self.requests).forEach(function(seq){\n            // restore saved domain\n            process.domain = self.domains[seq];\n            self.requests[seq].reject(err);\n\n            delete self.domains[seq];\n            delete self.requests[seq];\n        });\n    });\n\n    this.protocol.on('timeout', function(){\n        self.disconnect();\n    });\n\n    return connectDeferred.promise;\n};\n\nproto.disconnect = function(){\n    if(!this.protocol){\n        return;\n    }\n\n    this.disconnectDeferred = P.defer();\n    this.protocol.disconnect();\n\n    return this.disconnectDeferred.promise;\n};\n\nproto.request = function(connId, method, args){\n    if(!this.protocol){\n        throw new Error('not connected');\n    }\n\n    var seq = this.seq++;\n\n    var deferred = P.defer();\n    this.requests[seq] = deferred;\n\n    var msg = {\n        seq : seq,\n        connId : connId,\n        method : method,\n        args : args,\n    };\n\n    this.protocol.send(msg);\n\n    // save domain\n    this.domains[seq] = process.domain;\n\n    logger.info('%s:%s <= %j', this.protocol.socket.remoteAddress, this.protocol.socket.remotePort, msg);\n\n    return deferred.promise;\n};\n\nmodule.exports = Client;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/sample/node_modules/memdb-client/lib/protocol.js":"'use strict';\n\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar P = require('bluebird');\nvar logger = require('memdb-logger').getLogger('memdb-client', __filename);\n\nvar Protocol = function(opts){\n    EventEmitter.call(this);\n\n    opts = opts || {};\n\n    this.socket = opts.socket;\n    this.socket.setEncoding('utf8');\n\n    this.remainLine = '';\n\n    var self = this;\n    this.socket.on('data', function(data){\n        // message is json encoded and splited by '\\n'\n        var lines = data.split('\\n');\n        for(var i=0; i<lines.length - 1; i++){\n            try{\n                var msg = '';\n                if(i === 0){\n                    msg = JSON.parse(self.remainLine + lines[i]);\n                    self.remainLine = '';\n                }\n                else{\n                    msg = JSON.parse(lines[i]);\n                }\n                self.emit('msg', msg);\n            }\n            catch(err){\n                logger.error(err.stack);\n            }\n        }\n        self.remainLine = lines[lines.length - 1];\n    });\n\n    this.socket.on('close', function(hadError){\n        self.emit('close', hadError);\n    });\n\n    this.socket.on('connect', function(){\n        self.emit('connect');\n    });\n\n    this.socket.on('error', function(err){\n        self.emit('error', err);\n    });\n\n    this.socket.on('timeout', function(){\n        self.emit('timeout');\n    });\n};\n\nutil.inherits(Protocol, EventEmitter);\n\nProtocol.prototype.send = function(msg){\n    var data = JSON.stringify(msg) + '\\n';\n\n    var ret = this.socket.write(data);\n    if(!ret){\n        logger.warn('socket.write return false');\n    }\n};\n\nProtocol.prototype.disconnect = function(){\n    this.socket.end();\n};\n\nmodule.exports = Protocol;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/sample/node_modules/memdb-client/lib/consts.js":"'use strict';\n\nvar exports = {};\n\nexports.collMethods = ['find', 'findOne', 'findById',\n                    'findReadOnly', 'findOneReadOnly', 'findByIdReadOnly',\n                    'insert', 'update', 'remove', 'lock'];\n\nexports.connMethods = ['commit', 'rollback', 'eval', 'info', 'resetCounter', 'flushBackend', '$unload', '$findReadOnly'];\n\nexports.version = require('../package').version;\n\nmodule.exports = exports;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/sample/node_modules/memdb-client/lib/autoconnection.js":"'use strict';\n\nvar _ = require('lodash');\nvar domain = require('domain');\nvar P = require('bluebird');\nvar Connection = require('./connection');\nvar AsyncLock = require('async-lock');\nvar consts = require('./consts');\nvar uuid = require('node-uuid');\nvar logger = require('memdb-logger').getLogger('memdb-client', __filename);\n\n// Max connections per shard (max concurrent transactions per shard)\nvar DEFAULT_MAX_CONNECTION = 32;\n// Idle time before close connection\nvar DEFAULT_CONNECTION_IDLE_TIMEOUT = 600 * 1000;\n// Max pending tasks per shard\nvar DEFAULT_MAX_PENDING_TASK = 2048;\n\nvar DEFAULT_RECONNECT_INTERVAL = 2000;\n\n// Use one connection per transaction\n// Route request to shards\nvar AutoConnection = function(opts){\n    opts = opts || {};\n\n    this.db = opts.db;\n\n    this.config = {\n        maxConnection : opts.maxConnection || DEFAULT_MAX_CONNECTION,\n        connectionIdleTimeout : opts.connectionIdleTimeout || DEFAULT_CONNECTION_IDLE_TIMEOUT,\n        maxPendingTask : opts.maxPendingTask || DEFAULT_MAX_PENDING_TASK,\n        reconnectInterval : opts.reconnectInterval || DEFAULT_RECONNECT_INTERVAL,\n\n        // allow concurrent request inside one connection, internal use only\n        concurrentInConnection : opts.concurrentInConnection || false,\n\n        // {shardId : {host : '127.0.0.1', port : 31017}}\n        shards : opts.shards || {},\n    };\n\n    if(this.config.concurrentInConnection){\n        this.config.maxConnection = 1;\n    }\n\n    var shardIds = Object.keys(this.config.shards);\n    if(shardIds.length === 0){\n        throw new Error('please specify opts.shards');\n    }\n\n    var shards = {};\n    shardIds.forEach(function(shardId){\n        shards[shardId] = {\n            connections : {}, // {connId : connection}\n            freeConnections : {}, // {connId : true}\n            connectionTimeouts : {}, // {connId : timeout}\n            pendingTasks : [],\n            reconnectInterval : null,\n        };\n    });\n    this.shards = shards;\n\n    this.openConnectionLock = new AsyncLock({Promise : P, maxPending : 10000});\n    this.collections = {};\n};\n\nvar proto = AutoConnection.prototype;\n\nproto.close = function(){\n    var self = this;\n    // Close all connections to all shards\n    return P.map(Object.keys(this.shards), function(shardId){\n        var shard = self.shards[shardId];\n\n        clearInterval(shard.reconnectInterval);\n        shard.reconnectInterval = null;\n\n        // reject all pending tasks\n        shard.pendingTasks.forEach(function(task){\n            task.deferred.reject(new Error('connection closed'));\n        });\n        shard.pendingTasks = [];\n\n        // close all connections\n        var connections = shard.connections;\n        return P.map(Object.keys(connections), function(connId){\n            var conn = connections[connId];\n            if(conn){\n                return conn.close();\n            }\n        });\n    })\n    .then(function(){\n        logger.info('autoConnection closed');\n    })\n    .catch(function(err){\n        logger.error(err.stack);\n    });\n};\n\nproto.openConnection = function(shardId){\n    var self = this;\n\n    return this.openConnectionLock.acquire(shardId, function(){\n        var shard = self._shard(shardId);\n        if(Object.keys(shard.connections).length >= self.config.maxConnection){\n            return;\n        }\n\n        var conn = new Connection({\n                                host : self.config.shards[shardId].host,\n                                port : self.config.shards[shardId].port,\n                                idleTimeout : self.config.connectionIdleTimeout\n                            });\n\n        return conn.connect()\n        .then(function(connId){\n            clearInterval(shard.reconnectInterval);\n            shard.reconnectInterval = null;\n\n            shard.connections[connId] = conn;\n\n            logger.info('[shard:%s][conn:%s] open connection', shardId, connId);\n\n            shard.freeConnections[connId] = true;\n\n            conn.on('close', function(){\n                logger.info('[shard:%s][conn:%s] connection closed', shardId, connId);\n                delete shard.connections[connId];\n                delete shard.freeConnections[connId];\n            });\n\n            setImmediate(function(){\n                return self._runTask(shardId);\n            });\n        }, function(e){\n            if(!shard.reconnectInterval){\n                shard.reconnectInterval = setInterval(function(){\n                    return self.openConnection(shardId);\n                }, self.config.reconnectInterval);\n            }\n            logger.error(e.stack);\n\n            if(Object.keys(shard.connections).length === 0){\n                logger.error('No connection available for shard %s', shardId);\n\n                // no available connection, reject all pending tasks\n                shard.pendingTasks.forEach(function(task){\n                    task.deferred.reject(e);\n                });\n                shard.pendingTasks = [];\n            }\n        });\n    })\n    .catch(function(e){\n        logger.error(e.stack);\n    });\n};\n\nproto._task = function(method, args, shardId){\n    var deferred = P.defer();\n    try{\n        if(!shardId){\n            var shardIds = Object.keys(this.shards);\n            if(shardIds.length > 1){\n                throw new Error('You must specify shardId');\n            }\n            shardId = shardIds[0];\n        }\n\n        var shard = this._shard(shardId);\n\n        if(shard.pendingTasks.length >= this.config.maxPendingTask){\n            throw new Error('Too much pending tasks');\n        }\n\n        shard.pendingTasks.push({\n            method : method,\n            args : args,\n            deferred : deferred\n        });\n\n        var self = this;\n        setImmediate(function(){\n            return self._runTask(shardId);\n        });\n    }\n    catch(err){\n        deferred.reject(err);\n    }\n    finally{\n        return deferred.promise;\n    }\n};\n\nproto._runTask = function(shardId){\n    var self = this;\n    var shard = this._shard(shardId);\n\n    if(shard.pendingTasks.length === 0){\n        return;\n    }\n\n    var connIds = Object.keys(shard.freeConnections);\n    if(connIds.length === 0){\n        return this.openConnection(shardId);\n    }\n\n    var connId = connIds[0];\n    var conn = shard.connections[connId];\n    if(!this.config.concurrentInConnection){\n        delete shard.freeConnections[connId];\n    }\n\n    var task = shard.pendingTasks.shift();\n\n    if(this.config.concurrentInConnection){\n        // start run next before current task finish\n        setImmediate(function(){\n            self._runTask(shardId);\n        });\n    }\n\n    return P.try(function(){\n        if(task.method === '__t'){\n            var func = task.args[0];\n            return self._runTransaction(func, conn, shardId);\n        }\n        else{\n            var method = conn[task.method];\n            if(typeof(method) !== 'function'){\n                throw new Error('invalid method - ' + task.method);\n            }\n            return method.apply(conn, task.args);\n        }\n    })\n    .then(function(ret){\n        task.deferred.resolve(ret);\n    }, function(err){\n        task.deferred.reject(err);\n    })\n    .finally(function(){\n        if(shard.connections.hasOwnProperty(connId)){\n            shard.freeConnections[connId] = true;\n        }\n\n        setImmediate(function(){\n            self._runTask(shardId);\n        });\n    })\n    .catch(function(e){\n        logger.error(e.stack);\n    });\n};\n\nproto._runTransaction = function(func, conn, shardId){\n    if(typeof(func) !== 'function'){\n        throw new Error('Function is required');\n    }\n\n    var deferred = P.defer();\n\n    var scope = domain.create();\n    scope.__memdb__ = {shard: shardId, conn: conn._connId, trans : uuid.v4()};\n\n    var self = this;\n    scope.run(function(){\n        logger.info('[shard:%s][conn:%s] transaction start', shardId, conn._connId);\n\n        var startTick = Date.now();\n\n        return P.try(function(){\n            return func();\n        })\n        .then(function(ret){\n            return conn.commit()\n            .then(function(){\n                logger.info('[shard:%s][conn:%s] transaction done (%sms)', shardId, conn._connId, Date.now() - startTick);\n                delete scope.__memdb__;\n                deferred.resolve(ret);\n            });\n        }, function(err){\n            return conn.rollback()\n            .then(function(){\n                logger.error('[shard:%s][conn:%s] transaction error %s', shardId, conn._connId, err.stack);\n                delete scope.__memdb__;\n                deferred.reject(err);\n            });\n        })\n        .catch(function(e){\n            logger.error(e.stack);\n            deferred.reject(e);\n        });\n    });\n\n    return deferred.promise;\n};\n\n// Get connection from current scope\nproto._connection = function(){\n    var info = process.domain && process.domain.__memdb__;\n    if(!info){\n        throw new Error('You are not in any transaction scope');\n    }\n    var shard = this._shard(info.shard);\n    var conn = shard.connections[info.conn];\n    if(!conn){\n        throw new Error('connection ' + info.conn + ' not exist');\n    }\n    return conn;\n};\n\nproto._shard = function(shardId){\n    var shard = this.shards[shardId];\n    if(!shard){\n        throw new Error('shard ' + shardId + ' not exist');\n    }\n    return shard;\n};\n\nproto.collection = function(name){\n    var self = this;\n    if(!this.collections[name]){\n        var collection = {};\n        // Method must be called inside transaction\n        consts.collMethods.forEach(function(method){\n            collection[method] = function(){\n                var conn = self._connection();\n                var args = [name].concat([].slice.call(arguments));\n                return conn[method].apply(conn, args);\n            };\n        });\n\n        this.collections[name] = collection;\n    }\n    return this.collections[name];\n};\n\nconsts.connMethods.forEach(function(method){\n    if(method === 'commit' || method === 'rollback'){\n        return;\n    }\n    // Methods not bind to transaction\n    proto[method] = function(){\n        var shardId = arguments[0];\n        var args = [].slice.call(arguments, 1);\n        return this._task(method, args, shardId);\n    };\n});\n\nproto.transaction = function(func, shardId){\n    return this._task('__t', [func], shardId);\n};\n\nmodule.exports = AutoConnection;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/sample/mdbgoose.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n'use strict';\n\n// Add the following index config in memdb.conf.js and restart memdbcluster\n//\n// collections : {\n//     player : {\n//         indexes : [\n//             {\n//                 keys : ['areaId'],\n//                 valueIgnore : {\n//                     areaId : ['', -1],\n//                 },\n//             },\n//             {\n//                 keys : ['deviceType', 'deviceId'],\n//                 unique : true,\n//             },\n//         ]\n//     }\n// },\n\n// npm install memdb-client\n// run with node >= 0.12 with --harmony option\n\n// We assume you have started shard 's1' on localhost:31017\n\nvar memdb = require('memdb-client');\nvar P = memdb.Promise;\nvar mdbgoose = memdb.goose;\n\n// Define player schema\nvar playerSchema = new mdbgoose.Schema({\n    _id : String,\n    name : String,\n    areaId : Number,\n    deviceType : Number,\n    deviceId : String,\n    items : [mdbgoose.SchemaTypes.Mixed],\n}, {collection : 'player'});\n// Define player model\nvar Player = mdbgoose.model('player', playerSchema);\n\nvar main = P.coroutine(function*(){\n    // Connect to memdb\n    yield mdbgoose.connectAsync({\n        shards : { // specify all shards here\n            s1 : {host : '127.0.0.1', port: 31017},\n            s2 : {host : '127.0.0.1', port: 31018},\n        }\n    });\n\n    // Make a transaction in s1\n    yield mdbgoose.transactionAsync(P.coroutine(function*(){\n\n        var player = new Player({\n            _id : 'p1',\n            name: 'rain',\n            areaId : 1,\n            deviceType : 1,\n            deviceId : 'id1',\n            items : [],\n        });\n\n        // insert a player\n        yield player.saveAsync();\n\n        // find player by id\n        var doc = yield Player.findByIdAsync('p1');\n        console.log('%j', doc);\n\n        // find player by areaId, return array of players\n        var docs = yield Player.findAsync({areaId : 1});\n        console.log('%j', docs);\n\n        // find player by deviceType and deviceId\n        player = yield Player.findOneAsync({deviceType : 1, deviceId : 'id1'});\n\n        // update player\n        player.areaId = 2;\n        yield player.saveAsync();\n\n        // remove the player\n        yield player.removeAsync();\n\n    }), 's1');\n});\n\nif (require.main === module) {\n    main().finally(process.exit);\n}\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/sample/node_modules/memdb-client/lib/mdbgoose.js":"'use strict';\n\nvar path = require('path');\nglobal.MONGOOSE_DRIVER_PATH = '../../../../lib/mongoose-driver';\nvar P = require('bluebird');\nvar util = require('util');\nvar logger = require('memdb-logger').getLogger('memdb-client', __filename);\nvar memdb = require('./index');\n\nvar mongoose = require('mongoose');\n\n// save original connect\nvar connectMongo = mongoose.connect;\nvar disconnectMongo = mongoose.disconnect;\n\nmongoose.connect = function(opts){\n    var promise = P.bind(this)\n    .then(function(){\n        if(this._autoconn){\n            throw new Error('Already connected');\n        }\n        return memdb.autoConnect(opts);\n    })\n    .then(function(ret){\n        this._autoconn = ret;\n\n        if(opts && opts.backend){\n            return P.promisify(connectMongo, mongoose)(opts.backend.url);\n        }\n    });\n\n    var cb = arguments[arguments.length - 1];\n    if(typeof(cb) === 'function'){\n        return promise.nodeify(cb);\n    }\n    else{\n        return promise;\n    }\n};\n\nmongoose.disconnect = function(){\n    var promise = P.bind(this)\n    .then(function(){\n        return this.autoconn.close();\n    })\n    .then(function(){\n        this._autoconn = null;\n        return P.promisify(disconnectMongo, mongoose)();\n    });\n\n    var cb = arguments[arguments.length - 1];\n    if(typeof(cb) === 'function'){\n        return promise.nodeify(cb);\n    }\n    else{\n        return promise;\n    }\n};\n\nObject.defineProperty(mongoose, 'autoconn' , {\n    get : function(){\n        if(!mongoose._autoconn){\n            throw new Error('Please connect first');\n        }\n        return mongoose._autoconn;\n    }\n});\n\nmongoose.transaction = function(func, shardId, cb){\n    var promise = this.autoconn.transaction(func, shardId);\n\n    if(typeof(cb) === 'function'){\n        return promise.nodeify(cb);\n    }\n    else{\n        return promise;\n    }\n};\n\n// Parse mongoose model to generate collection config (indexes)\nmongoose.genCollectionConfig = function(){\n    var collections = {};\n\n    for(var name in mongoose.models){\n        var model = mongoose.models[name];\n        var schema = model.schema;\n        var collname = model.collection.name;\n\n        if(!collections[collname]){\n            collections[collname] = {};\n        }\n        var collection = collections[collname];\n        if(!collection.indexes){\n            collection.indexes = [];\n        }\n\n        var paths = schema.paths;\n        var index = null, mdbIndex = null;\n        for(var field in paths){\n            if(field === '_id' || field.indexOf('.') !== -1){\n                continue; //ignore compound field and _id\n            }\n            index = paths[field]._index;\n            if(!!index){\n                mdbIndex = {keys : [field]};\n                if(!!index.unique){\n                    mdbIndex.unique = true;\n                }\n\n                mdbIndex.valueIgnore = {};\n                mdbIndex.valueIgnore[field] = paths[field].options.indexIgnore || [];\n                collection.indexes.push(mdbIndex);\n            }\n        }\n\n        if(!!schema._indexes){\n            for(var i in schema._indexes){\n                index = schema._indexes[i];\n                mdbIndex = {keys : [], valueIgnore : {}};\n                for(field in index[0]){\n                    if(index[0][field]){\n                        mdbIndex.keys.push(field);\n                        mdbIndex.valueIgnore[field] = paths[field].options.indexIgnore || [];\n                    }\n                }\n                if(index[1] && !!index[1].unique){\n                    mdbIndex.unique = true;\n                }\n                collection.indexes.push(mdbIndex);\n            }\n        }\n\n        //Disable versionkey\n        schema.options.versionKey = false;\n    }\n\n    logger.info('parsed collection config : %j', collections);\n    return collections;\n};\n\n\nvar Model = mongoose.Model;\n\nModel.findMongo = function(query, cb){\n    return this.find.apply(this, [].slice.call(arguments)).comment('$mongo');\n};\n\nModel.findOneMongo = function(){\n    return this.findOne.apply(this, [].slice.call(arguments)).comment('$mongo');\n};\n\nModel.findByIdMongo = function(){\n    return this.findById.apply(this, [].slice.call(arguments)).comment('$mongo');\n};\n\nModel.findReadOnly = function(){\n    return this.find.apply(this, [].slice.call(arguments)).comment('$readonly');\n};\n\nModel.findOneReadOnly = function(){\n    return this.findOne.apply(this, [].slice.call(arguments)).comment('$readonly');\n};\n\nModel.findByIdReadOnly = function(){\n    return this.findById.apply(this, [].slice.call(arguments)).comment('$readonly');\n};\n\n// var overwrited = ['insert', 'save', 'remove', 'update'];\n\n// for (var i = overwrited.length - 1; i >= 0; i--) {\n//     (function(funcName){\n//         var oldFunc = Model.prototype[funcName];\n//         Model.prototype[funcName] = function (fn) {\n//             if(this.__readonly__) {\n//                 return fn(new Error('document is readonly'));\n//             }\n//             oldFunc.apply(this, arguments);\n//         };\n//     })(overwrited[i]); //jshint ignore:line\n// }\n\nvar overwrited = ['findByIdAndRemove', 'findByIdAndUpdate', 'findOneAndUpdate', 'findOneAndRemove'];\n\nfor (var i = overwrited.length - 1; i >= 0; i--) {\n    (function(funcName){\n        mongoose.Model[funcName] = function(){\n            var cb = arguments[arguments.length-1];\n            if(typeof(cb) === 'function') {\n                cb(new Error(util.format('not implemented method: ', funcName)));\n            } else {\n                throw new Error(util.format('not implemented method: ', funcName));\n            }\n        };\n    })(overwrited[i]); //jshint ignore:line\n}\n\nmodule.exports = P.promisifyAll(mongoose);\n\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/lib/mongoose-driver/binary.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n/* jshint ignore:start */\n\n/*!\n * Module dependencies.\n */\n\nvar Binary = require('mongodb').Binary;\n\nmodule.exports = exports = Binary;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/lib/mongoose-driver/objectid.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n/* jshint ignore:start */\n\n/*!\n * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId\n * @constructor NodeMongoDbObjectId\n * @see ObjectId\n */\n\nvar ObjectId = require('mongodb').ObjectId;\n\n/*!\n * ignore\n */\n\nmodule.exports = exports = ObjectId;\n","/home/travis/build/npmtest/node-npmtest-memdb-server/node_modules/memdb-server/lib/mongoose-driver/ReadPreference.js":"// Copyright 2015 The MemDB Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License. See the AUTHORS file\n// for names of contributors.\n\n/* jshint ignore:start */\n\n/*!\n * Module dependencies.\n */\n\nvar mongodb = require('mongodb');\nvar ReadPref = mongodb.ReadPreference;\n\n/*!\n * Converts arguments to ReadPrefs the driver\n * can understand.\n *\n * @param {String|Array} pref\n * @param {Array} [tags]\n */\n\nmodule.exports = function readPref (pref, tags) {\n  if (Array.isArray(pref)) {\n    tags = pref[1];\n    pref = pref[0];\n  }\n\n  if (pref instanceof ReadPref) {\n    return pref;\n  }\n\n  switch (pref) {\n    case 'p':\n      pref = 'primary';\n      break;\n    case 'pp':\n      pref = 'primaryPreferred';\n      break;\n    case 's':\n      pref = 'secondary';\n      break;\n    case 'sp':\n      pref = 'secondaryPreferred';\n      break;\n    case 'n':\n      pref = 'nearest';\n      break;\n  }\n\n  return new ReadPref(pref, tags);\n}\n"}